{"version":3,"sources":["../browser/src/query-builder/ReturningResultsEntityUpdator.ts"],"names":[],"mappings":"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","file":"ReturningResultsEntityUpdator.js","sourcesContent":["import {ObjectLiteral} from \"../common/ObjectLiteral\";\nimport {QueryRunner} from \"../query-runner/QueryRunner\";\nimport {OrmUtils} from \"../util/OrmUtils\";\nimport {QueryExpressionMap} from \"./QueryExpressionMap\";\nimport {ColumnMetadata} from \"../metadata/ColumnMetadata\";\nimport {UpdateResult} from \"./result/UpdateResult\";\nimport {InsertResult} from \"./result/InsertResult\";\nimport {OracleDriver} from \"../driver/oracle/OracleDriver\";\n\n/**\n * Updates entity with returning results in the entity insert and update operations.\n */\nexport class ReturningResultsEntityUpdator {\n\n    // -------------------------------------------------------------------------\n    // Constructor\n    // -------------------------------------------------------------------------\n\n    constructor(protected queryRunner: QueryRunner,\n                protected expressionMap: QueryExpressionMap) {\n    }\n\n    // -------------------------------------------------------------------------\n    // Public Methods\n    // -------------------------------------------------------------------------\n\n    /**\n     * Updates entities with a special columns after updation query execution.\n     */\n    async update(updateResult: UpdateResult, entities: ObjectLiteral[]): Promise<void> {\n        const metadata = this.expressionMap.mainAlias!.metadata;\n\n        await Promise.all(entities.map(async (entity, entityIndex) => {\n\n            // if database supports returning/output statement then we already should have updating values in the raw data returned by insert query\n            if (this.queryRunner.connection.driver.isReturningSqlSupported()) {\n                if (this.queryRunner.connection.driver instanceof OracleDriver && Array.isArray(updateResult.raw) && this.expressionMap.extraReturningColumns.length > 0) {\n                    updateResult.raw = updateResult.raw.reduce((newRaw, rawItem, rawItemIndex) => {\n                        newRaw[this.expressionMap.extraReturningColumns[rawItemIndex].databaseName] = rawItem[0];\n                        return newRaw;\n                    }, {} as ObjectLiteral);\n                }\n                const result = Array.isArray(updateResult.raw) ? updateResult.raw[entityIndex] : updateResult.raw;\n                const returningColumns = this.queryRunner.connection.driver.createGeneratedMap(metadata, result);\n                if (returningColumns) {\n                    this.queryRunner.manager.merge(metadata.target as any, entity, returningColumns);\n                    updateResult.generatedMaps.push(returningColumns);\n                }\n\n            } else {\n\n                // for driver which do not support returning/output statement we need to perform separate query and load what we need\n                const updationColumns = this.getUpdationReturningColumns();\n                if (updationColumns.length > 0) {\n\n                    // get entity id by which we will get needed data\n                    const entityId = this.expressionMap.mainAlias!.metadata.getEntityIdMap(entity);\n                    if (!entityId)\n                        throw new Error(`Cannot update entity because entity id is not set in the entity.`);\n\n                    // execute query to get needed data\n                    const loadedReturningColumns = await this.queryRunner.manager\n                        .createQueryBuilder()\n                        .select(metadata.primaryColumns.map(column => metadata.targetName + \".\" + column.propertyPath))\n                        .addSelect(this.getUpdationReturningColumns().map(column => metadata.targetName + \".\" + column.propertyPath))\n                        .from(metadata.target, metadata.targetName)\n                        .where(entityId)\n                        .setOption(\"create-pojo\") // use POJO because created object can contain default values, e.g. property = null and those properties maight be overridden by merge process\n                        .getOne() as any;\n\n                    if (loadedReturningColumns) {\n                        this.queryRunner.manager.merge(metadata.target as any, entity, loadedReturningColumns);\n                        updateResult.generatedMaps.push(loadedReturningColumns);\n                    }\n                }\n            }\n        }));\n    }\n\n    /**\n     * Updates entities with a special columns after insertion query execution.\n     */\n    async insert(insertResult: InsertResult, entities: ObjectLiteral[]): Promise<void> {\n        const metadata = this.expressionMap.mainAlias!.metadata;\n        const insertionColumns = this.getInsertionReturningColumns();\n\n        const generatedMaps = entities.map((entity, entityIndex) => {\n            if (this.queryRunner.connection.driver instanceof OracleDriver && Array.isArray(insertResult.raw) && this.expressionMap.extraReturningColumns.length > 0) {\n                insertResult.raw = insertResult.raw.reduce((newRaw, rawItem, rawItemIndex) => {\n                    newRaw[this.expressionMap.extraReturningColumns[rawItemIndex].databaseName] = rawItem[0];\n                    return newRaw;\n                }, {} as ObjectLiteral);\n            }\n            // get all values generated by a database for us\n            const result = Array.isArray(insertResult.raw) ? insertResult.raw[entityIndex] : insertResult.raw;\n            const generatedMap = this.queryRunner.connection.driver.createGeneratedMap(metadata, result, entityIndex, entities.length) || {};\n\n            // if database does not support uuid generation we need to get uuid values\n            // generated by orm and set them to the generatedMap\n            if (this.queryRunner.connection.driver.isUUIDGenerationSupported() === false) {\n                metadata.generatedColumns.forEach(generatedColumn => {\n                    if (generatedColumn.generationStrategy === \"uuid\") {\n                        // uuid can be defined by user in a model, that's why first we get it\n                        let uuid = generatedColumn.getEntityValue(entity);\n                        if (!uuid) // if it was not defined by a user then InsertQueryBuilder generates it by its own, get this generated uuid value\n                            uuid = this.expressionMap.nativeParameters[\"uuid_\" + generatedColumn.databaseName + entityIndex];\n\n                        OrmUtils.mergeDeep(generatedMap, generatedColumn.createValueMap(uuid));\n                    }\n                });\n            }\n\n            this.queryRunner.manager.merge(metadata.target as any, entity, generatedMap); // todo: this should not be here, but problem with below line\n            return generatedMap;\n        });\n\n        // for postgres and mssql we use returning/output statement to get values of inserted default and generated values\n        // for other drivers we have to re-select this data from the database\n        if (this.queryRunner.connection.driver.isReturningSqlSupported() === false && insertionColumns.length > 0) {\n            const entityIds = entities.map((entity) => {\n                const entityId = metadata.getEntityIdMap(entity)!;\n\n                // We have to check for an empty `entityId` - if we don't, the query against the database\n                // effectively drops the `where` clause entirely and the first record will be returned -\n                // not what we want at all.\n                if (!entityId)\n                    throw new Error(`Cannot update entity because entity id is not set in the entity.`);\n\n                return entityId;\n            });\n\n            // to select just inserted entities we need a criteria to select by.\n            // for newly inserted entities in drivers which do not support returning statement\n            // row identifier can only be an increment column\n            // (since its the only thing that can be generated by those databases)\n            // or (and) other primary key which is defined by a user and inserted value has it\n\n            const returningResult: any = await this.queryRunner.manager\n                .createQueryBuilder()\n                .select(metadata.primaryColumns.map(column => metadata.targetName + \".\" + column.propertyPath))\n                .addSelect(insertionColumns.map(column => metadata.targetName + \".\" + column.propertyPath))\n                .from(metadata.target, metadata.targetName)\n                .where(entityIds)\n                .setOption(\"create-pojo\") // use POJO because created object can contain default values, e.g. property = null and those properties maight be overridden by merge process\n                .getMany();\n\n            entities.forEach((entity, entityIndex) => {\n                this.queryRunner.manager.merge(metadata.target as any, generatedMaps[entityIndex], returningResult[entityIndex]);\n            });\n        }\n\n        entities.forEach((entity, entityIndex) => {\n            const entityId = metadata.getEntityIdMap(entity)!;\n            insertResult.identifiers.push(entityId);\n            insertResult.generatedMaps.push(generatedMaps[entityIndex]);\n            this.queryRunner.manager.merge(this.expressionMap.mainAlias!.metadata.target as any, entity, generatedMaps[entityIndex], generatedMaps[entityIndex]); // todo: why twice?!\n        });\n    }\n\n    /**\n     * Columns we need to be returned from the database when we insert entity.\n     */\n    getInsertionReturningColumns(): ColumnMetadata[] {\n\n        // for databases which support returning statement we need to return extra columns like id\n        // for other databases we don't need to return id column since its returned by a driver already\n        const needToCheckGenerated = this.queryRunner.connection.driver.isReturningSqlSupported();\n\n        // filter out the columns of which we need database inserted values to update our entity\n        return this.expressionMap.mainAlias!.metadata.columns.filter(column => {\n            return  column.default !== undefined ||\n                    (needToCheckGenerated && column.isGenerated)  ||\n                    column.isCreateDate ||\n                    column.isUpdateDate ||\n                    column.isDeleteDate ||\n                    column.isVersion;\n        });\n    }\n\n    /**\n     * Columns we need to be returned from the database when we update entity.\n     */\n    getUpdationReturningColumns(): ColumnMetadata[] {\n        return this.expressionMap.mainAlias!.metadata.columns.filter(column => {\n            return column.isUpdateDate || column.isVersion;\n        });\n    }\n\n}\n"],"sourceRoot":".."}