import { __awaiter } from "tslib";
import { CockroachDriver } from "../driver/cockroachdb/CockroachDriver";
import { OracleDriver } from "../driver/oracle/OracleDriver";
import { QueryBuilder } from "./QueryBuilder";
import { SqlServerDriver } from "../driver/sqlserver/SqlServerDriver";
import { PostgresDriver } from "../driver/postgres/PostgresDriver";
import { DeleteResult } from "./result/DeleteResult";
import { ReturningStatementNotSupportedError } from "../error/ReturningStatementNotSupportedError";
import { SqljsDriver } from "../driver/sqljs/SqljsDriver";
import { MysqlDriver } from "../driver/mysql/MysqlDriver";
import { BroadcasterResult } from "../subscriber/BroadcasterResult";
import { EntitySchema } from "../index";
import { AuroraDataApiDriver } from "../driver/aurora-data-api/AuroraDataApiDriver";
import { BetterSqlite3Driver } from "../driver/better-sqlite3/BetterSqlite3Driver";
/**
 * Allows to build complex sql queries in a fashion way and execute those queries.
 */
export class DeleteQueryBuilder extends QueryBuilder {
    // -------------------------------------------------------------------------
    // Constructor
    // -------------------------------------------------------------------------
    constructor(connectionOrQueryBuilder, queryRunner) {
        super(connectionOrQueryBuilder, queryRunner);
        this.expressionMap.aliasNamePrefixingEnabled = false;
    }
    // -------------------------------------------------------------------------
    // Public Implemented Methods
    // -------------------------------------------------------------------------
    /**
     * Gets generated sql query without parameters being replaced.
     */
    getQuery() {
        let sql = this.createComment();
        sql += this.createDeleteExpression();
        return sql.trim();
    }
    /**
     * Executes sql generated by query builder and returns raw database results.
     */
    execute() {
        return __awaiter(this, void 0, void 0, function* () {
            const [sql, parameters] = this.getQueryAndParameters();
            const queryRunner = this.obtainQueryRunner();
            let transactionStartedByUs = false;
            try {
                // start transaction if it was enabled
                if (this.expressionMap.useTransaction === true && queryRunner.isTransactionActive === false) {
                    yield queryRunner.startTransaction();
                    transactionStartedByUs = true;
                }
                // call before deletion methods in listeners and subscribers
                if (this.expressionMap.callListeners === true && this.expressionMap.mainAlias.hasMetadata) {
                    const broadcastResult = new BroadcasterResult();
                    queryRunner.broadcaster.broadcastBeforeRemoveEvent(broadcastResult, this.expressionMap.mainAlias.metadata);
                    if (broadcastResult.promises.length > 0)
                        yield Promise.all(broadcastResult.promises);
                }
                // execute query
                const deleteResult = new DeleteResult();
                const result = yield queryRunner.query(sql, parameters);
                const driver = queryRunner.connection.driver;
                if (driver instanceof MysqlDriver) {
                    deleteResult.raw = result;
                    deleteResult.affected = result.affectedRows;
                }
                else if (driver instanceof AuroraDataApiDriver) {
                    deleteResult.raw = result;
                    deleteResult.affected = result.numberOfRecordsUpdated;
                }
                else if (driver instanceof SqlServerDriver || driver instanceof PostgresDriver || driver instanceof CockroachDriver) {
                    deleteResult.raw = result[0] ? result[0] : null;
                    // don't return 0 because it could confuse. null means that we did not receive this value
                    deleteResult.affected = typeof result[1] === "number" ? result[1] : null;
                }
                else if (driver instanceof OracleDriver) {
                    deleteResult.affected = result;
                }
                else if (driver instanceof BetterSqlite3Driver) { // only works for better-sqlite3
                    deleteResult.raw = result;
                    deleteResult.affected = result.changes;
                }
                else {
                    deleteResult.raw = result;
                }
                // call after deletion methods in listeners and subscribers
                if (this.expressionMap.callListeners === true && this.expressionMap.mainAlias.hasMetadata) {
                    const broadcastResult = new BroadcasterResult();
                    queryRunner.broadcaster.broadcastAfterRemoveEvent(broadcastResult, this.expressionMap.mainAlias.metadata);
                    if (broadcastResult.promises.length > 0)
                        yield Promise.all(broadcastResult.promises);
                }
                // close transaction if we started it
                if (transactionStartedByUs)
                    yield queryRunner.commitTransaction();
                return deleteResult;
            }
            catch (error) {
                // rollback transaction if we started it
                if (transactionStartedByUs) {
                    try {
                        yield queryRunner.rollbackTransaction();
                    }
                    catch (rollbackError) { }
                }
                throw error;
            }
            finally {
                if (queryRunner !== this.queryRunner) { // means we created our own query runner
                    yield queryRunner.release();
                }
                if (this.connection.driver instanceof SqljsDriver && !queryRunner.isTransactionActive) {
                    yield this.connection.driver.autoSave();
                }
            }
        });
    }
    // -------------------------------------------------------------------------
    // Public Methods
    // -------------------------------------------------------------------------
    /**
     * Specifies FROM which entity's table select/update/delete will be executed.
     * Also sets a main string alias of the selection data.
     */
    from(entityTarget, aliasName) {
        entityTarget = entityTarget instanceof EntitySchema ? entityTarget.options.name : entityTarget;
        const mainAlias = this.createFromAlias(entityTarget, aliasName);
        this.expressionMap.setMainAlias(mainAlias);
        return this;
    }
    /**
     * Sets WHERE condition in the query builder.
     * If you had previously WHERE expression defined,
     * calling this function will override previously set WHERE conditions.
     * Additionally you can add parameters used in where expression.
     */
    where(where, parameters) {
        this.expressionMap.wheres = []; // don't move this block below since computeWhereParameter can add where expressions
        const condition = this.computeWhereParameter(where);
        if (condition)
            this.expressionMap.wheres = [{ type: "simple", condition: condition }];
        if (parameters)
            this.setParameters(parameters);
        return this;
    }
    /**
     * Adds new AND WHERE condition in the query builder.
     * Additionally you can add parameters used in where expression.
     */
    andWhere(where, parameters) {
        this.expressionMap.wheres.push({ type: "and", condition: this.computeWhereParameter(where) });
        if (parameters)
            this.setParameters(parameters);
        return this;
    }
    /**
     * Adds new OR WHERE condition in the query builder.
     * Additionally you can add parameters used in where expression.
     */
    orWhere(where, parameters) {
        this.expressionMap.wheres.push({ type: "or", condition: this.computeWhereParameter(where) });
        if (parameters)
            this.setParameters(parameters);
        return this;
    }
    /**
     * Adds new AND WHERE with conditions for the given ids.
     */
    whereInIds(ids) {
        return this.where(this.createWhereIdsExpression(ids));
    }
    /**
     * Adds new AND WHERE with conditions for the given ids.
     */
    andWhereInIds(ids) {
        return this.andWhere(this.createWhereIdsExpression(ids));
    }
    /**
     * Adds new OR WHERE with conditions for the given ids.
     */
    orWhereInIds(ids) {
        return this.orWhere(this.createWhereIdsExpression(ids));
    }
    /**
     * Optional returning/output clause.
     */
    output(output) {
        return this.returning(output);
    }
    /**
     * Optional returning/output clause.
     */
    returning(returning) {
        // not all databases support returning/output cause
        if (!this.connection.driver.isReturningSqlSupported())
            throw new ReturningStatementNotSupportedError();
        this.expressionMap.returning = returning;
        return this;
    }
    // -------------------------------------------------------------------------
    // Protected Methods
    // -------------------------------------------------------------------------
    /**
     * Creates DELETE express used to perform query.
     */
    createDeleteExpression() {
        const tableName = this.getTableName(this.getMainTableName());
        const whereExpression = this.createWhereExpression();
        const returningExpression = this.createReturningExpression();
        if (returningExpression && (this.connection.driver instanceof PostgresDriver || this.connection.driver instanceof CockroachDriver)) {
            return `DELETE FROM ${tableName}${whereExpression} RETURNING ${returningExpression}`;
        }
        else if (returningExpression !== "" && this.connection.driver instanceof SqlServerDriver) {
            return `DELETE FROM ${tableName} OUTPUT ${returningExpression}${whereExpression}`;
        }
        else {
            return `DELETE FROM ${tableName}${whereExpression}`;
        }
    }
}

//# sourceMappingURL=DeleteQueryBuilder.js.map
