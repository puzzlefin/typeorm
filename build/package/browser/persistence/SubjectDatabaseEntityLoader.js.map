{"version":3,"sources":["../browser/src/persistence/SubjectDatabaseEntityLoader.ts"],"names":[],"mappings":"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","file":"SubjectDatabaseEntityLoader.js","sourcesContent":["import {Subject} from \"./Subject\";\nimport {ObjectLiteral} from \"../common/ObjectLiteral\";\nimport {QueryRunner} from \"../query-runner/QueryRunner\";\nimport {FindManyOptions} from \"../find-options/FindManyOptions\";\n\n/**\n * Loads database entities for all operate subjects which do not have database entity set.\n * All entities that we load database entities for are marked as updated or inserted.\n * To understand which of them really needs to be inserted or updated we need to load\n * their original representations from the database.\n */\nexport class SubjectDatabaseEntityLoader {\n\n    // ---------------------------------------------------------------------\n    // Constructor\n    // ---------------------------------------------------------------------\n\n    constructor(protected queryRunner: QueryRunner,\n                protected subjects: Subject[]) {\n    }\n\n    // ---------------------------------------------------------------------\n    // Public Methods\n    // ---------------------------------------------------------------------\n\n    /**\n     * Loads database entities for all subjects.\n     *\n     * loadAllRelations flag is used to load all relation ids of the object, no matter if they present in subject entity or not.\n     * This option is used for deletion.\n     */\n    async load(operationType: \"save\"|\"remove\"|\"soft-remove\"|\"recover\"): Promise<void> {\n\n        // we are grouping subjects by target to perform more optimized queries using WHERE IN operator\n        // go through the groups and perform loading of database entities of each subject in the group\n        const promises = this.groupByEntityTargets().map(async subjectGroup => {\n\n            // prepare entity ids of the subjects we need to load\n            const allIds: ObjectLiteral[] = [];\n            const allSubjects: Subject[] = [];\n            subjectGroup.subjects.forEach(subject => {\n\n                // we don't load if subject already has a database entity loaded\n                if (subject.databaseEntity || !subject.identifier)\n                    return;\n\n                allIds.push(subject.identifier);\n                allSubjects.push(subject);\n            });\n\n            // if there no ids found (means all entities are new and have generated ids) - then nothing to load there\n            if (!allIds.length)\n                return;\n\n            const loadRelationPropertyPaths: string[] = [];\n\n            // for the save, soft-remove and recover operation\n            // extract all property paths of the relations we need to load relation ids for\n            // this is for optimization purpose - this way we don't load relation ids for entities\n            // whose relations are undefined, and since they are undefined its really pointless to\n            // load something for them, since undefined properties are skipped by the orm\n            if (operationType === \"save\" || operationType === \"soft-remove\" || operationType === \"recover\") {\n                subjectGroup.subjects.forEach(subject => {\n\n                    // gets all relation property paths that exist in the persisted entity.\n                    subject.metadata.relations.forEach(relation => {\n                        const value = relation.getEntityValue(subject.entityWithFulfilledIds!);\n                        if (value === undefined)\n                            return;\n\n                        if (loadRelationPropertyPaths.indexOf(relation.propertyPath) === -1)\n                            loadRelationPropertyPaths.push(relation.propertyPath);\n                    });\n                });\n            } else { // remove\n\n                // for remove operation\n                // we only need to load junction relation ids since only they are removed by cascades\n                loadRelationPropertyPaths.push(...subjectGroup.subjects[0].metadata.manyToManyRelations.map(relation => relation.propertyPath));\n            }\n\n            const findOptions: FindManyOptions<any> = {\n                loadEagerRelations: false,\n                loadRelationIds: {\n                    relations: loadRelationPropertyPaths,\n                    disableMixedMap: true\n                },\n                // the soft-deleted entities should be included in the loaded entities for recover operation\n                withDeleted: true\n            };\n\n            // load database entities for all given ids\n            const entities = await this.queryRunner.manager\n                .getRepository<ObjectLiteral>(subjectGroup.target)\n                .findByIds(allIds, findOptions);\n\n            // now when we have entities we need to find subject of each entity\n            // and insert that entity into database entity of the found subjects\n            entities.forEach(entity => {\n                const subjects = this.findByPersistEntityLike(subjectGroup.target, entity);\n                subjects.forEach(subject => {\n                  subject.databaseEntity = entity;\n                  if (!subject.identifier)\n                      subject.identifier = subject.metadata.hasAllPrimaryKeys(entity) ? subject.metadata.getEntityIdMap(entity) : undefined;\n                });\n            });\n\n            // this way we tell what subjects we tried to load database entities of\n            for (let subject of allSubjects) {\n                subject.databaseEntityLoaded = true;\n            }\n        });\n\n        await Promise.all(promises);\n    }\n\n    // ---------------------------------------------------------------------\n    // Protected Methods\n    // ---------------------------------------------------------------------\n\n    /**\n     * Finds subjects where entity like given subject's entity.\n     * Comparision made by entity id.\n     * Multiple subjects may be returned if duplicates are present in the subject array.\n     * This will likely result in the same row being updated multiple times during a transaction.\n     */\n    protected findByPersistEntityLike(entityTarget: Function|string, entity: ObjectLiteral): Subject[] {\n        return this.subjects.filter(subject => {\n            if (!subject.entity)\n                return false;\n\n            if (subject.entity === entity)\n                return true;\n\n            return subject.metadata.target === entityTarget && subject.metadata.compareEntities(subject.entityWithFulfilledIds!, entity);\n        });\n    }\n\n    /**\n     * Groups given Subject objects into groups separated by entity targets.\n     */\n    protected groupByEntityTargets(): { target: Function|string, subjects: Subject[] }[] {\n        return this.subjects.reduce((groups, operatedEntity) => {\n            let group = groups.find(group => group.target === operatedEntity.metadata.target);\n            if (!group) {\n                group = { target: operatedEntity.metadata.target, subjects: [] };\n                groups.push(group);\n            }\n            group.subjects.push(operatedEntity);\n            return groups;\n        }, [] as { target: Function|string, subjects: Subject[] }[]);\n    }\n\n}\n"],"sourceRoot":".."}