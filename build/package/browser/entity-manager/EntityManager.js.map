{"version":3,"sources":["../browser/src/entity-manager/EntityManager.ts"],"names":[],"mappings":"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","file":"EntityManager.js","sourcesContent":["import {Connection} from \"../connection/Connection\";\nimport {FindManyOptions} from \"../find-options/FindManyOptions\";\nimport {EntityTarget} from \"../common/EntityTarget\";\nimport {ObjectType} from \"../common/ObjectType\";\nimport {EntityNotFoundError} from \"../error/EntityNotFoundError\";\nimport {QueryRunnerProviderAlreadyReleasedError} from \"../error/QueryRunnerProviderAlreadyReleasedError\";\nimport {FindOneOptions} from \"../find-options/FindOneOptions\";\nimport {DeepPartial} from \"../common/DeepPartial\";\nimport {RemoveOptions} from \"../repository/RemoveOptions\";\nimport {SaveOptions} from \"../repository/SaveOptions\";\nimport {NoNeedToReleaseEntityManagerError} from \"../error/NoNeedToReleaseEntityManagerError\";\nimport {MongoRepository} from \"../repository/MongoRepository\";\nimport {TreeRepository} from \"../repository/TreeRepository\";\nimport {Repository} from \"../repository/Repository\";\nimport {FindOptionsUtils} from \"../find-options/FindOptionsUtils\";\nimport {PlainObjectToNewEntityTransformer} from \"../query-builder/transformer/PlainObjectToNewEntityTransformer\";\nimport {PlainObjectToDatabaseEntityTransformer} from \"../query-builder/transformer/PlainObjectToDatabaseEntityTransformer\";\nimport {CustomRepositoryNotFoundError} from \"../error/CustomRepositoryNotFoundError\";\nimport {EntitySchema, getMetadataArgsStorage, ObjectLiteral} from \"../index\";\nimport {AbstractRepository} from \"../repository/AbstractRepository\";\nimport {CustomRepositoryCannotInheritRepositoryError} from \"../error/CustomRepositoryCannotInheritRepositoryError\";\nimport {QueryRunner} from \"../query-runner/QueryRunner\";\nimport {SelectQueryBuilder} from \"../query-builder/SelectQueryBuilder\";\nimport {MongoDriver} from \"../driver/mongodb/MongoDriver\";\nimport {RepositoryNotFoundError} from \"../error/RepositoryNotFoundError\";\nimport {RepositoryNotTreeError} from \"../error/RepositoryNotTreeError\";\nimport {RepositoryFactory} from \"../repository/RepositoryFactory\";\nimport {TreeRepositoryNotSupportedError} from \"../error/TreeRepositoryNotSupportedError\";\nimport {QueryDeepPartialEntity} from \"../query-builder/QueryPartialEntity\";\nimport {EntityPersistExecutor} from \"../persistence/EntityPersistExecutor\";\nimport {ObjectID} from \"../driver/mongodb/typings\";\nimport {InsertResult} from \"../query-builder/result/InsertResult\";\nimport {UpdateResult} from \"../query-builder/result/UpdateResult\";\nimport {DeleteResult} from \"../query-builder/result/DeleteResult\";\nimport {FindConditions} from \"../find-options/FindConditions\";\nimport {IsolationLevel} from \"../driver/types/IsolationLevel\";\nimport {ObjectUtils} from \"../util/ObjectUtils\";\n\n/**\n * Entity manager supposed to work with any entity, automatically find its repository and call its methods,\n * whatever entity type are you passing.\n */\nexport class EntityManager {\n\n    // -------------------------------------------------------------------------\n    // Public Properties\n    // -------------------------------------------------------------------------\n\n    /**\n     * Connection used by this entity manager.\n     */\n    readonly connection: Connection;\n\n    /**\n     * Custom query runner to be used for operations in this entity manager.\n     * Used only in non-global entity manager.\n     */\n    readonly queryRunner?: QueryRunner;\n\n    // -------------------------------------------------------------------------\n    // Protected Properties\n    // -------------------------------------------------------------------------\n\n    /**\n     * Once created and then reused by en repositories.\n     */\n    protected repositories: Repository<any>[] = [];\n\n    /**\n     * Plain to object transformer used in create and merge operations.\n     */\n    protected plainObjectToEntityTransformer = new PlainObjectToNewEntityTransformer();\n\n    // -------------------------------------------------------------------------\n    // Constructor\n    // -------------------------------------------------------------------------\n\n    constructor(connection: Connection, queryRunner?: QueryRunner) {\n        this.connection = connection;\n        if (queryRunner) {\n            this.queryRunner = queryRunner;\n            // dynamic: this.queryRunner = manager;\n            ObjectUtils.assign(this.queryRunner, { manager: this });\n        }\n    }\n\n    // -------------------------------------------------------------------------\n    // Public Methods\n    // -------------------------------------------------------------------------\n\n    /**\n     * Wraps given function execution (and all operations made there) in a transaction.\n     * All database operations must be executed using provided entity manager.\n     */\n    async transaction<T>(runInTransaction: (entityManager: EntityManager) => Promise<T>): Promise<T>;\n\n    /**\n     * Wraps given function execution (and all operations made there) in a transaction.\n     * All database operations must be executed using provided entity manager.\n     */\n    async transaction<T>(isolationLevel: IsolationLevel, runInTransaction: (entityManager: EntityManager) => Promise<T>): Promise<T>;\n\n    /**\n     * Wraps given function execution (and all operations made there) in a transaction.\n     * All database operations must be executed using provided entity manager.\n     */\n    async transaction<T>(\n        isolationOrRunInTransaction: IsolationLevel | ((entityManager: EntityManager) => Promise<T>),\n        runInTransactionParam?: (entityManager: EntityManager) => Promise<T>\n    ): Promise<T> {\n\n        const isolation = typeof isolationOrRunInTransaction === \"string\" ? isolationOrRunInTransaction : undefined;\n        const runInTransaction = typeof isolationOrRunInTransaction === \"function\" ? isolationOrRunInTransaction : runInTransactionParam;\n\n        if (!runInTransaction) {\n            throw new Error(`Transaction method requires callback in second paramter if isolation level is supplied.`);\n        }\n\n        if (this.connection.driver instanceof MongoDriver)\n            throw new Error(`Transactions aren't supported by MongoDB.`);\n\n        if (this.queryRunner && this.queryRunner.isReleased)\n            throw new QueryRunnerProviderAlreadyReleasedError();\n\n        if (this.queryRunner && this.queryRunner.isTransactionActive)\n            throw new Error(`Cannot start transaction because its already started`);\n\n        // if query runner is already defined in this class, it means this entity manager was already created for a single connection\n        // if its not defined we create a new query runner - single connection where we'll execute all our operations\n        const queryRunner = this.queryRunner || this.connection.createQueryRunner();\n\n        try {\n            if (isolation) {\n                await queryRunner.startTransaction(isolation);\n              } else {\n                await queryRunner.startTransaction();\n              }\n            const result = await runInTransaction(queryRunner.manager);\n            await queryRunner.commitTransaction();\n            return result;\n\n        } catch (err) {\n            try { // we throw original error even if rollback thrown an error\n                await queryRunner.rollbackTransaction();\n            } catch (rollbackError) { }\n            throw err;\n\n        } finally {\n            if (!this.queryRunner) // if we used a new query runner provider then release it\n                await queryRunner.release();\n        }\n    }\n\n    /**\n     * Executes raw SQL query and returns raw database results.\n     */\n    async query(query: string, parameters?: any[]): Promise<any> {\n        return this.connection.query(query, parameters, this.queryRunner);\n    }\n\n    /**\n     * Creates a new query builder that can be used to build a sql query.\n     */\n    createQueryBuilder<Entity extends ObjectLiteral>(entityClass: EntityTarget<Entity>, alias: string, queryRunner?: QueryRunner): SelectQueryBuilder<Entity>;\n\n    /**\n     * Creates a new query builder that can be used to build a sql query.\n     */\n    createQueryBuilder(queryRunner?: QueryRunner): SelectQueryBuilder<any>;\n\n    /**\n     * Creates a new query builder that can be used to build a sql query.\n     */\n    createQueryBuilder<Entity extends ObjectLiteral>(entityClass?: EntityTarget<Entity>|QueryRunner, alias?: string, queryRunner?: QueryRunner): SelectQueryBuilder<Entity> {\n        if (alias) {\n            return this.connection.createQueryBuilder(entityClass as EntityTarget<Entity>, alias, queryRunner || this.queryRunner);\n\n        } else {\n            return this.connection.createQueryBuilder(entityClass as QueryRunner|undefined || queryRunner || this.queryRunner);\n        }\n    }\n\n    /**\n     * Checks if entity has an id.\n     */\n    hasId(entity: any): boolean;\n\n    /**\n     * Checks if entity of given schema name has an id.\n     */\n    hasId(target: Function|string, entity: any): boolean;\n\n    /**\n     * Checks if entity has an id by its Function type or schema name.\n     */\n    hasId(targetOrEntity: any|Function|string, maybeEntity?: any): boolean {\n        const target = arguments.length === 2 ? targetOrEntity : targetOrEntity.constructor;\n        const entity = arguments.length === 2 ? maybeEntity : targetOrEntity;\n        const metadata = this.connection.getMetadata(target);\n        return metadata.hasId(entity);\n    }\n\n    /**\n     * Gets entity mixed id.\n     */\n    getId(entity: any): any;\n\n    /**\n     * Gets entity mixed id.\n     */\n    getId(target: EntityTarget<any>, entity: any): any;\n\n    /**\n     * Gets entity mixed id.\n     */\n    getId(targetOrEntity: any|EntityTarget<any>, maybeEntity?: any): any {\n        const target = arguments.length === 2 ? targetOrEntity : targetOrEntity.constructor;\n        const entity = arguments.length === 2 ? maybeEntity : targetOrEntity;\n        const metadata = this.connection.getMetadata(target);\n        return metadata.getEntityIdMixedMap(entity);\n    }\n\n    /**\n     * Creates a new entity instance and copies all entity properties from this object into a new entity.\n     * Note that it copies only properties that present in entity schema.\n     */\n    create<Entity>(entityClass: EntityTarget<Entity>, plainObject?: DeepPartial<Entity>): Entity;\n\n    /**\n     * Creates a new entities and copies all entity properties from given objects into their new entities.\n     * Note that it copies only properties that present in entity schema.\n     */\n    create<Entity>(entityClass: EntityTarget<Entity>, plainObjects?: DeepPartial<Entity>[]): Entity[];\n\n    /**\n     * Creates a new entity instance or instances.\n     * Can copy properties from the given object into new entities.\n     */\n    create<Entity>(entityClass: EntityTarget<Entity>, plainObjectOrObjects?: DeepPartial<Entity>|DeepPartial<Entity>[]): Entity|Entity[] {\n        const metadata = this.connection.getMetadata(entityClass);\n\n        if (!plainObjectOrObjects)\n            return metadata.create(this.queryRunner);\n\n        if (Array.isArray(plainObjectOrObjects))\n            return plainObjectOrObjects.map(plainEntityLike => this.create(entityClass as any, plainEntityLike));\n\n        const mergeIntoEntity = metadata.create(this.queryRunner);\n        this.plainObjectToEntityTransformer.transform(mergeIntoEntity, plainObjectOrObjects, metadata, true);\n        return mergeIntoEntity;\n    }\n\n    /**\n     * Merges two entities into one new entity.\n     */\n    merge<Entity extends ObjectLiteral>(entityClass: EntityTarget<Entity>, mergeIntoEntity: Entity, ...entityLikes: DeepPartial<Entity>[]): Entity { // todo: throw exception if entity manager is released\n        const metadata = this.connection.getMetadata(entityClass);\n        entityLikes.forEach(object => this.plainObjectToEntityTransformer.transform(mergeIntoEntity, object, metadata));\n        return mergeIntoEntity;\n    }\n\n    /**\n     * Creates a new entity from the given plain javascript object. If entity already exist in the database, then\n     * it loads it (and everything related to it), replaces all values with the new ones from the given object\n     * and returns this new entity. This new entity is actually a loaded from the db entity with all properties\n     * replaced from the new object.\n     */\n    async preload<Entity extends ObjectLiteral>(entityClass: EntityTarget<Entity>, entityLike: DeepPartial<Entity>): Promise<Entity|undefined> {\n        const metadata = this.connection.getMetadata(entityClass);\n        const plainObjectToDatabaseEntityTransformer = new PlainObjectToDatabaseEntityTransformer(this.connection.manager);\n        const transformedEntity = await plainObjectToDatabaseEntityTransformer.transform(entityLike, metadata);\n        if (transformedEntity)\n            return this.merge(entityClass as any, transformedEntity as Entity, entityLike);\n\n        return undefined;\n    }\n\n    /**\n     * Saves all given entities in the database.\n     * If entities do not exist in the database then inserts, otherwise updates.\n     */\n    save<Entity>(entities: Entity[], options?: SaveOptions): Promise<Entity[]>;\n\n    /**\n     * Saves all given entities in the database.\n     * If entities do not exist in the database then inserts, otherwise updates.\n     */\n    save<Entity>(entity: Entity, options?: SaveOptions): Promise<Entity>;\n\n    /**\n     * Saves all given entities in the database.\n     * If entities do not exist in the database then inserts, otherwise updates.\n     */\n    save<Entity, T extends DeepPartial<Entity>>(targetOrEntity: EntityTarget<Entity>, entities: T[], options: SaveOptions & { reload: false }): Promise<T[]>;\n\n    /**\n     * Saves all given entities in the database.\n     * If entities do not exist in the database then inserts, otherwise updates.\n     */\n    save<Entity, T extends DeepPartial<Entity>>(targetOrEntity: EntityTarget<Entity>, entities: T[], options?: SaveOptions): Promise<(T & Entity)[]>;\n\n    /**\n     * Saves a given entity in the database.\n     * If entity does not exist in the database then inserts, otherwise updates.\n     */\n    save<Entity, T extends DeepPartial<Entity>>(targetOrEntity: EntityTarget<Entity>, entity: T, options: SaveOptions & { reload: false }): Promise<T>;\n\n    /**\n     * Saves a given entity in the database.\n     * If entity does not exist in the database then inserts, otherwise updates.\n     */\n    save<Entity, T extends DeepPartial<Entity>>(targetOrEntity: EntityTarget<Entity>, entity: T, options?: SaveOptions): Promise<T & Entity>;\n\n    /**\n     * Saves a given entity in the database.\n     */\n    save<Entity, T extends DeepPartial<Entity>>(targetOrEntity: (T|T[])|EntityTarget<Entity>, maybeEntityOrOptions?: T|T[], maybeOptions?: SaveOptions): Promise<T|T[]> {\n\n        // normalize mixed parameters\n        let target = (arguments.length > 1 && (targetOrEntity instanceof Function || targetOrEntity instanceof EntitySchema || typeof targetOrEntity === \"string\")) ? targetOrEntity as Function|string : undefined;\n        const entity: T|T[] = target ? maybeEntityOrOptions as T|T[] : targetOrEntity as T|T[];\n        const options = target ? maybeOptions : maybeEntityOrOptions as SaveOptions;\n\n        if (target instanceof EntitySchema)\n            target = target.options.name;\n\n        // if user passed empty array of entities then we don't need to do anything\n        if (Array.isArray(entity) && entity.length === 0)\n            return Promise.resolve(entity);\n\n        // execute save operation\n        return new EntityPersistExecutor(this.connection, this.queryRunner, \"save\", target, entity, options)\n            .execute()\n            .then(() => entity);\n    }\n\n    /**\n     * Removes a given entity from the database.\n     */\n    remove<Entity>(entity: Entity, options?: RemoveOptions): Promise<Entity>;\n\n    /**\n     * Removes a given entity from the database.\n     */\n    remove<Entity>(targetOrEntity: EntityTarget<Entity>, entity: Entity, options?: RemoveOptions): Promise<Entity>;\n\n    /**\n     * Removes a given entity from the database.\n     */\n    remove<Entity>(entity: Entity[], options?: RemoveOptions): Promise<Entity>;\n\n    /**\n     * Removes a given entity from the database.\n     */\n    remove<Entity>(targetOrEntity: EntityTarget<Entity>, entity: Entity[], options?: RemoveOptions): Promise<Entity[]>;\n\n    /**\n     * Removes a given entity from the database.\n     */\n    remove<Entity extends ObjectLiteral>(targetOrEntity: (Entity|Entity[])|EntityTarget<Entity>, maybeEntityOrOptions?: Entity|Entity[], maybeOptions?: RemoveOptions): Promise<Entity|Entity[]> {\n\n        // normalize mixed parameters\n        const target = (arguments.length > 1 && (targetOrEntity instanceof Function || typeof targetOrEntity === \"string\")) ? targetOrEntity as Function|string : undefined;\n        const entity: Entity|Entity[] = target ? maybeEntityOrOptions as Entity|Entity[] : targetOrEntity as Entity|Entity[];\n        const options = target ? maybeOptions : maybeEntityOrOptions as SaveOptions;\n\n        // if user passed empty array of entities then we don't need to do anything\n        if (Array.isArray(entity) && entity.length === 0)\n            return Promise.resolve(entity);\n\n        // execute save operation\n        return new EntityPersistExecutor(this.connection, this.queryRunner, \"remove\", target, entity, options)\n            .execute()\n            .then(() => entity);\n    }\n\n    /**\n     * Records the delete date of all given entities.\n     */\n    softRemove<Entity>(entities: Entity[], options?: SaveOptions): Promise<Entity[]>;\n\n    /**\n     * Records the delete date of a given entity.\n     */\n    softRemove<Entity>(entity: Entity, options?: SaveOptions): Promise<Entity>;\n\n    /**\n     * Records the delete date of all given entities.\n     */\n    softRemove<Entity, T extends DeepPartial<Entity>>(targetOrEntity: EntityTarget<Entity>, entities: T[], options?: SaveOptions): Promise<T[]>;\n\n    /**\n     * Records the delete date of a given entity.\n     */\n    softRemove<Entity, T extends DeepPartial<Entity>>(targetOrEntity: EntityTarget<Entity>, entity: T, options?: SaveOptions): Promise<T>;\n\n    /**\n     * Records the delete date of one or many given entities.\n     */\n    softRemove<Entity, T extends DeepPartial<Entity>>(targetOrEntity: (T|T[])|EntityTarget<Entity>, maybeEntityOrOptions?: T|T[], maybeOptions?: SaveOptions): Promise<T|T[]> {\n\n        // normalize mixed parameters\n        let target = (arguments.length > 1 && (targetOrEntity instanceof Function || targetOrEntity instanceof EntitySchema || typeof targetOrEntity === \"string\")) ? targetOrEntity as Function|string : undefined;\n        const entity: T|T[] = target ? maybeEntityOrOptions as T|T[] : targetOrEntity as T|T[];\n        const options = target ? maybeOptions : maybeEntityOrOptions as SaveOptions;\n\n        if (target instanceof EntitySchema)\n            target = target.options.name;\n\n        // if user passed empty array of entities then we don't need to do anything\n        if (Array.isArray(entity) && entity.length === 0)\n            return Promise.resolve(entity);\n\n        // execute soft-remove operation\n        return new EntityPersistExecutor(this.connection, this.queryRunner, \"soft-remove\", target, entity, options)\n            .execute()\n            .then(() => entity);\n    }\n\n    /**\n     * Recovers all given entities.\n     */\n    recover<Entity>(entities: Entity[], options?: SaveOptions): Promise<Entity[]>;\n\n    /**\n     * Recovers a given entity.\n     */\n    recover<Entity>(entity: Entity, options?: SaveOptions): Promise<Entity>;\n\n    /**\n     * Recovers all given entities.\n     */\n    recover<Entity, T extends DeepPartial<Entity>>(targetOrEntity: EntityTarget<Entity>, entities: T[], options?: SaveOptions): Promise<T[]>;\n\n    /**\n     * Recovers a given entity.\n     */\n    recover<Entity, T extends DeepPartial<Entity>>(targetOrEntity: EntityTarget<Entity>, entity: T, options?: SaveOptions): Promise<T>;\n\n    /**\n     * Recovers one or many given entities.\n     */\n    recover<Entity, T extends DeepPartial<Entity>>(targetOrEntity: (T|T[])|EntityTarget<Entity>, maybeEntityOrOptions?: T|T[], maybeOptions?: SaveOptions): Promise<T|T[]> {\n\n        // normalize mixed parameters\n        let target = (arguments.length > 1 && (targetOrEntity instanceof Function || targetOrEntity instanceof EntitySchema || typeof targetOrEntity === \"string\")) ? targetOrEntity as Function|string : undefined;\n        const entity: T|T[] = target ? maybeEntityOrOptions as T|T[] : targetOrEntity as T|T[];\n        const options = target ? maybeOptions : maybeEntityOrOptions as SaveOptions;\n\n        if (target instanceof EntitySchema)\n            target = target.options.name;\n\n        // if user passed empty array of entities then we don't need to do anything\n        if (Array.isArray(entity) && entity.length === 0)\n            return Promise.resolve(entity);\n\n        // execute recover operation\n        return new EntityPersistExecutor(this.connection, this.queryRunner, \"recover\", target, entity, options)\n            .execute()\n            .then(() => entity);\n    }\n\n    /**\n     * Inserts a given entity into the database.\n     * Unlike save method executes a primitive operation without cascades, relations and other operations included.\n     * Executes fast and efficient INSERT query.\n     * Does not check if entity exist in the database, so query will fail if duplicate entity is being inserted.\n     * You can execute bulk inserts using this method.\n     */\n    async insert<Entity extends ObjectLiteral>(target: EntityTarget<Entity>, entity: QueryDeepPartialEntity<Entity>|(QueryDeepPartialEntity<Entity>[])): Promise<InsertResult> {\n        return this.createQueryBuilder()\n            .insert()\n            .into(target)\n            .values(entity)\n            .execute();\n    }\n\n    /**\n     * Updates entity partially. Entity can be found by a given condition(s).\n     * Unlike save method executes a primitive operation without cascades, relations and other operations included.\n     * Executes fast and efficient UPDATE query.\n     * Does not check if entity exist in the database.\n     * Condition(s) cannot be empty.\n     */\n    update<Entity>(target: EntityTarget<Entity>, criteria: string|string[]|number|number[]|Date|Date[]|ObjectID|ObjectID[]|any, partialEntity: QueryDeepPartialEntity<Entity>): Promise<UpdateResult> {\n\n        // if user passed empty criteria or empty list of criterias, then throw an error\n        if (criteria === undefined ||\n            criteria === null ||\n            criteria === \"\" ||\n            (Array.isArray(criteria) && criteria.length === 0)) {\n\n            return Promise.reject(new Error(`Empty criteria(s) are not allowed for the update method.`));\n        }\n\n        if (typeof criteria === \"string\" ||\n            typeof criteria === \"number\" ||\n            criteria instanceof Date ||\n            Array.isArray(criteria)) {\n\n            return this.createQueryBuilder()\n                .update(target)\n                .set(partialEntity)\n                .whereInIds(criteria)\n                .execute();\n\n        } else {\n            return this.createQueryBuilder()\n                .update(target)\n                .set(partialEntity)\n                .where(criteria)\n                .execute();\n        }\n    }\n\n    /**\n     * Deletes entities by a given condition(s).\n     * Unlike save method executes a primitive operation without cascades, relations and other operations included.\n     * Executes fast and efficient DELETE query.\n     * Does not check if entity exist in the database.\n     * Condition(s) cannot be empty.\n     */\n    delete<Entity extends ObjectLiteral>(targetOrEntity: EntityTarget<Entity>, criteria: string|string[]|number|number[]|Date|Date[]|ObjectID|ObjectID[]|any): Promise<DeleteResult> {\n\n        // if user passed empty criteria or empty list of criterias, then throw an error\n        if (criteria === undefined ||\n            criteria === null ||\n            criteria === \"\" ||\n            (Array.isArray(criteria) && criteria.length === 0)) {\n\n            return Promise.reject(new Error(`Empty criteria(s) are not allowed for the delete method.`));\n        }\n\n        if (typeof criteria === \"string\" ||\n            typeof criteria === \"number\" ||\n            criteria instanceof Date ||\n            Array.isArray(criteria)) {\n\n            return this.createQueryBuilder()\n                .delete()\n                .from(targetOrEntity)\n                .whereInIds(criteria)\n                .execute();\n\n        } else {\n            return this.createQueryBuilder()\n                .delete()\n                .from(targetOrEntity)\n                .where(criteria)\n                .execute();\n        }\n    }\n\n    /**\n     * Records the delete date of entities by a given condition(s).\n     * Unlike save method executes a primitive operation without cascades, relations and other operations included.\n     * Executes fast and efficient DELETE query.\n     * Does not check if entity exist in the database.\n     * Condition(s) cannot be empty.\n     */\n    softDelete<Entity extends ObjectLiteral>(targetOrEntity: EntityTarget<Entity>, criteria: string|string[]|number|number[]|Date|Date[]|ObjectID|ObjectID[]|any): Promise<UpdateResult> {\n\n        // if user passed empty criteria or empty list of criterias, then throw an error\n        if (criteria === undefined ||\n            criteria === null ||\n            criteria === \"\" ||\n            (Array.isArray(criteria) && criteria.length === 0)) {\n\n            return Promise.reject(new Error(`Empty criteria(s) are not allowed for the delete method.`));\n        }\n\n        if (typeof criteria === \"string\" ||\n            typeof criteria === \"number\" ||\n            criteria instanceof Date ||\n            Array.isArray(criteria)) {\n\n            return this.createQueryBuilder()\n                .softDelete()\n                .from(targetOrEntity)\n                .whereInIds(criteria)\n                .execute();\n\n        } else {\n            return this.createQueryBuilder()\n                .softDelete()\n                .from(targetOrEntity)\n                .where(criteria)\n                .execute();\n        }\n    }\n\n    /**\n     * Restores entities by a given condition(s).\n     * Unlike save method executes a primitive operation without cascades, relations and other operations included.\n     * Executes fast and efficient DELETE query.\n     * Does not check if entity exist in the database.\n     * Condition(s) cannot be empty.\n     */\n    restore<Entity extends ObjectLiteral>(targetOrEntity: EntityTarget<Entity>, criteria: string|string[]|number|number[]|Date|Date[]|ObjectID|ObjectID[]|any): Promise<UpdateResult> {\n\n        // if user passed empty criteria or empty list of criterias, then throw an error\n        if (criteria === undefined ||\n            criteria === null ||\n            criteria === \"\" ||\n            (Array.isArray(criteria) && criteria.length === 0)) {\n\n            return Promise.reject(new Error(`Empty criteria(s) are not allowed for the delete method.`));\n        }\n\n        if (typeof criteria === \"string\" ||\n            typeof criteria === \"number\" ||\n            criteria instanceof Date ||\n            Array.isArray(criteria)) {\n\n            return this.createQueryBuilder()\n                .restore()\n                .from(targetOrEntity)\n                .whereInIds(criteria)\n                .execute();\n\n        } else {\n            return this.createQueryBuilder()\n                .restore()\n                .from(targetOrEntity)\n                .where(criteria)\n                .execute();\n        }\n    }\n\n    /**\n     * Counts entities that match given options.\n     * Useful for pagination.\n     */\n    count<Entity>(entityClass: EntityTarget<Entity>, options?: FindOneOptions<Entity>): Promise<number>;\n\n    /**\n     * Counts entities that match given options.\n     * Useful for pagination.\n     */\n    count<Entity>(entityClass: EntityTarget<Entity>, options?: FindManyOptions<Entity>): Promise<number>;\n\n    /**\n     * Counts entities that match given conditions.\n     * Useful for pagination.\n     */\n    count<Entity>(entityClass: EntityTarget<Entity>, conditions?: FindConditions<Entity>): Promise<number>;\n\n    /**\n     * Counts entities that match given find options or conditions.\n     * Useful for pagination.\n     */\n    async count<Entity extends ObjectLiteral>(entityClass: EntityTarget<Entity>, optionsOrConditions?: FindConditions<Entity>|FindOneOptions<Entity>|FindManyOptions<Entity>): Promise<number> {\n        const metadata = this.connection.getMetadata(entityClass);\n        const qb = this.createQueryBuilder(entityClass, FindOptionsUtils.extractFindManyOptionsAlias(optionsOrConditions) || metadata.name);\n        return FindOptionsUtils.applyFindManyOptionsOrConditionsToQueryBuilder(qb, optionsOrConditions).getCount();\n    }\n\n    /**\n     * Finds entities that match given options.\n     */\n    find<Entity>(entityClass: EntityTarget<Entity>, options?: FindManyOptions<Entity>): Promise<Entity[]>;\n\n    /**\n     * Finds entities that match given conditions.\n     */\n    find<Entity>(entityClass: EntityTarget<Entity>, conditions?: FindConditions<Entity>): Promise<Entity[]>;\n\n    /**\n     * Finds entities that match given find options or conditions.\n     */\n    async find<Entity extends ObjectLiteral>(entityClass: EntityTarget<Entity>, optionsOrConditions?: FindManyOptions<Entity>|FindConditions<Entity>): Promise<Entity[]> {\n        const metadata = this.connection.getMetadata(entityClass);\n        const qb = this.createQueryBuilder<Entity>(entityClass as any, FindOptionsUtils.extractFindManyOptionsAlias(optionsOrConditions) || metadata.name);\n\n        if (!FindOptionsUtils.isFindManyOptions(optionsOrConditions) || optionsOrConditions.loadEagerRelations !== false)\n            FindOptionsUtils.joinEagerRelations(qb, qb.alias, metadata);\n\n        return FindOptionsUtils.applyFindManyOptionsOrConditionsToQueryBuilder(qb, optionsOrConditions).getMany();\n    }\n\n    /**\n     * Finds entities that match given find options.\n     * Also counts all entities that match given conditions,\n     * but ignores pagination settings (from and take options).\n     */\n    findAndCount<Entity>(entityClass: EntityTarget<Entity>, options?: FindManyOptions<Entity>): Promise<[Entity[], number]>;\n\n    /**\n     * Finds entities that match given conditions.\n     * Also counts all entities that match given conditions,\n     * but ignores pagination settings (from and take options).\n     */\n    findAndCount<Entity>(entityClass: EntityTarget<Entity>, conditions?: FindConditions<Entity>): Promise<[Entity[], number]>;\n\n    /**\n     * Finds entities that match given find options and conditions.\n     * Also counts all entities that match given conditions,\n     * but ignores pagination settings (from and take options).\n     */\n    async findAndCount<Entity extends ObjectLiteral>(entityClass: EntityTarget<Entity>, optionsOrConditions?: FindConditions<Entity>|FindManyOptions<Entity>): Promise<[Entity[], number]> {\n        const metadata = this.connection.getMetadata(entityClass);\n        const qb = this.createQueryBuilder<Entity>(entityClass as any, FindOptionsUtils.extractFindManyOptionsAlias(optionsOrConditions) || metadata.name);\n\n        if (!FindOptionsUtils.isFindManyOptions(optionsOrConditions) || optionsOrConditions.loadEagerRelations !== false)\n            FindOptionsUtils.joinEagerRelations(qb, qb.alias, metadata);\n\n        return FindOptionsUtils.applyFindManyOptionsOrConditionsToQueryBuilder(qb, optionsOrConditions).getManyAndCount();\n    }\n\n    /**\n     * Finds entities with ids.\n     * Optionally find options can be applied.\n     */\n    findByIds<Entity>(entityClass: EntityTarget<Entity>, ids: any[], options?: FindManyOptions<Entity>): Promise<Entity[]>;\n\n    /**\n     * Finds entities with ids.\n     * Optionally conditions can be applied.\n     */\n    findByIds<Entity>(entityClass: EntityTarget<Entity>, ids: any[], conditions?: FindConditions<Entity>): Promise<Entity[]>;\n\n    /**\n     * Finds entities with ids.\n     * Optionally find options or conditions can be applied.\n     */\n    async findByIds<Entity extends ObjectLiteral>(entityClass: EntityTarget<Entity>, ids: any[], optionsOrConditions?: FindConditions<Entity>|FindManyOptions<Entity>): Promise<Entity[]> {\n\n        // if no ids passed, no need to execute a query - just return an empty array of values\n        if (!ids.length)\n            return Promise.resolve([]);\n        const metadata = this.connection.getMetadata(entityClass);\n        const qb = this.createQueryBuilder<Entity>(entityClass as any, FindOptionsUtils.extractFindManyOptionsAlias(optionsOrConditions) || metadata.name);\n        FindOptionsUtils.applyFindManyOptionsOrConditionsToQueryBuilder(qb, optionsOrConditions);\n\n        if (!FindOptionsUtils.isFindManyOptions(optionsOrConditions) || optionsOrConditions.loadEagerRelations !== false)\n            FindOptionsUtils.joinEagerRelations(qb, qb.alias, metadata);\n\n        return qb.andWhereInIds(ids).getMany();\n    }\n\n    /**\n     * Finds first entity that matches given find options.\n     */\n    findOne<Entity>(entityClass: EntityTarget<Entity>, id?: string|number|Date|ObjectID, options?: FindOneOptions<Entity>): Promise<Entity|undefined>;\n\n    /**\n     * Finds first entity that matches given find options.\n     */\n    findOne<Entity>(entityClass: EntityTarget<Entity>, options?: FindOneOptions<Entity>): Promise<Entity|undefined>;\n\n    /**\n     * Finds first entity that matches given conditions.\n     */\n    findOne<Entity>(entityClass: EntityTarget<Entity>, conditions?: FindConditions<Entity>, options?: FindOneOptions<Entity>): Promise<Entity|undefined>;\n\n    /**\n     * Finds first entity that matches given conditions.\n     */\n    async findOne<Entity extends ObjectLiteral>(entityClass: EntityTarget<Entity>, idOrOptionsOrConditions?: string|string[]|number|number[]|Date|Date[]|ObjectID|ObjectID[]|FindOneOptions<Entity>|FindConditions<Entity>, maybeOptions?: FindOneOptions<Entity>): Promise<Entity|undefined> {\n\n        let findOptions: FindManyOptions<any>|FindOneOptions<any>|undefined = undefined;\n        if (FindOptionsUtils.isFindOneOptions(idOrOptionsOrConditions)) {\n            findOptions = idOrOptionsOrConditions;\n        } else if (maybeOptions && FindOptionsUtils.isFindOneOptions(maybeOptions)) {\n            findOptions = maybeOptions;\n        }\n\n        let options: ObjectLiteral|undefined = undefined;\n        if (idOrOptionsOrConditions instanceof Object && !FindOptionsUtils.isFindOneOptions(idOrOptionsOrConditions))\n            options = idOrOptionsOrConditions as ObjectLiteral;\n\n        const metadata = this.connection.getMetadata(entityClass);\n        let alias: string = metadata.name;\n        if (findOptions && findOptions.join) {\n            alias = findOptions.join.alias;\n\n        } else if (maybeOptions && FindOptionsUtils.isFindOneOptions(maybeOptions) && maybeOptions.join) {\n            alias = maybeOptions.join.alias;\n        }\n        const qb = this.createQueryBuilder<Entity>(entityClass as any, alias);\n\n        if (!findOptions || findOptions.loadEagerRelations !== false)\n            FindOptionsUtils.joinEagerRelations(qb, qb.alias, qb.expressionMap.mainAlias!.metadata);\n\n        const passedId = typeof idOrOptionsOrConditions === \"string\" || typeof idOrOptionsOrConditions === \"number\" || (idOrOptionsOrConditions as any) instanceof Date;\n\n        if (!passedId) {\n            findOptions = {\n                ...(findOptions || {}),\n                take: 1,\n            };\n        }\n\n        FindOptionsUtils.applyOptionsToQueryBuilder(qb, findOptions);\n\n        if (options) {\n            qb.where(options);\n\n        } else if (passedId) {\n            qb.andWhereInIds(metadata.ensureEntityIdMap(idOrOptionsOrConditions));\n        }\n\n        return qb.getOne();\n    }\n\n    /**\n     * Finds first entity that matches given find options or rejects the returned promise on error.\n     */\n    findOneOrFail<Entity>(entityClass: EntityTarget<Entity>, id?: string|number|Date|ObjectID, options?: FindOneOptions<Entity>): Promise<Entity>;\n\n    /**\n     * Finds first entity that matches given find options or rejects the returned promise on error.\n     */\n    findOneOrFail<Entity>(entityClass: EntityTarget<Entity>, options?: FindOneOptions<Entity>): Promise<Entity>;\n\n    /**\n     * Finds first entity that matches given conditions or rejects the returned promise on error.\n     */\n    findOneOrFail<Entity>(entityClass: EntityTarget<Entity>, conditions?: FindConditions<Entity>, options?: FindOneOptions<Entity>): Promise<Entity>;\n\n    /**\n     * Finds first entity that matches given conditions or rejects the returned promise on error.\n     */\n    async findOneOrFail<Entity>(entityClass: EntityTarget<Entity>, idOrOptionsOrConditions?: string|string[]|number|number[]|Date|Date[]|ObjectID|ObjectID[]|FindOneOptions<Entity>|FindConditions<Entity>, maybeOptions?: FindOneOptions<Entity>): Promise<Entity> {\n        return this.findOne<Entity>(entityClass as any, idOrOptionsOrConditions as any, maybeOptions).then((value) => {\n            if (value === undefined) {\n                return Promise.reject(new EntityNotFoundError(entityClass, idOrOptionsOrConditions));\n            }\n            return Promise.resolve(value);\n        });\n    }\n\n    /**\n     * Clears all the data from the given table (truncates/drops it).\n     *\n     * Note: this method uses TRUNCATE and may not work as you expect in transactions on some platforms.\n     * @see https://stackoverflow.com/a/5972738/925151\n     */\n    async clear<Entity>(entityClass: EntityTarget<Entity>): Promise<void> {\n        const metadata = this.connection.getMetadata(entityClass);\n        const queryRunner = this.queryRunner || this.connection.createQueryRunner();\n        try {\n            return await queryRunner.clearTable(metadata.tablePath); // await is needed here because we are using finally\n\n        } finally {\n            if (!this.queryRunner)\n                await queryRunner.release();\n        }\n    }\n\n    /**\n     * Increments some column by provided value of the entities matched given conditions.\n     */\n    async increment<Entity extends ObjectLiteral>(entityClass: EntityTarget<Entity>,\n                            conditions: any,\n                            propertyPath: string,\n                            value: number | string): Promise<UpdateResult> {\n\n        const metadata = this.connection.getMetadata(entityClass);\n        const column = metadata.findColumnWithPropertyPath(propertyPath);\n        if (!column)\n            throw new Error(`Column ${propertyPath} was not found in ${metadata.targetName} entity.`);\n\n        if (isNaN(Number(value)))\n            throw new Error(`Value \"${value}\" is not a number.`);\n\n        // convert possible embeded path \"social.likes\" into object { social: { like: () => value } }\n        const values: QueryDeepPartialEntity<Entity> = propertyPath\n            .split(\".\")\n            .reduceRight(\n                (value, key) => ({ [key]: value }) as any,\n                () => this.connection.driver.escape(column.databaseName) + \" + \" + value\n            );\n\n        return this\n            .createQueryBuilder<Entity>(entityClass as any, \"entity\")\n            .update(entityClass)\n            .set(values)\n            .where(conditions)\n            .execute();\n    }\n\n    /**\n     * Decrements some column by provided value of the entities matched given conditions.\n     */\n    async decrement<Entity extends ObjectLiteral>(entityClass: EntityTarget<Entity>,\n                            conditions: any,\n                            propertyPath: string,\n                            value: number | string): Promise<UpdateResult> {\n\n        const metadata = this.connection.getMetadata(entityClass);\n        const column = metadata.findColumnWithPropertyPath(propertyPath);\n        if (!column)\n            throw new Error(`Column ${propertyPath} was not found in ${metadata.targetName} entity.`);\n\n        if (isNaN(Number(value)))\n            throw new Error(`Value \"${value}\" is not a number.`);\n\n        // convert possible embeded path \"social.likes\" into object { social: { like: () => value } }\n        const values: QueryDeepPartialEntity<Entity> = propertyPath\n            .split(\".\")\n            .reduceRight(\n                (value, key) => ({ [key]: value }) as any,\n                () => this.connection.driver.escape(column.databaseName) + \" - \" + value\n            );\n\n        return this\n            .createQueryBuilder<Entity>(entityClass as any, \"entity\")\n            .update(entityClass)\n            .set(values)\n            .where(conditions)\n            .execute();\n    }\n\n    /**\n     * Gets repository for the given entity class or name.\n     * If single database connection mode is used, then repository is obtained from the\n     * repository aggregator, where each repository is individually created for this entity manager.\n     * When single database connection is not used, repository is being obtained from the connection.\n     */\n    getRepository<Entity extends ObjectLiteral>(target: EntityTarget<Entity>): Repository<Entity> {\n\n        // throw exception if there is no repository with this target registered\n        if (!this.connection.hasMetadata(target))\n            throw new RepositoryNotFoundError(this.connection.name, target);\n\n        // find already created repository instance and return it if found\n        const metadata = this.connection.getMetadata(target);\n        const repository = this.repositories.find(repository => repository.metadata === metadata);\n        if (repository)\n            return repository;\n\n        // if repository was not found then create it, store its instance and return it\n        const newRepository = new RepositoryFactory().create(this, metadata, this.queryRunner);\n        this.repositories.push(newRepository);\n        return newRepository;\n    }\n\n    /**\n     * Gets tree repository for the given entity class or name.\n     * If single database connection mode is used, then repository is obtained from the\n     * repository aggregator, where each repository is individually created for this entity manager.\n     * When single database connection is not used, repository is being obtained from the connection.\n     */\n    getTreeRepository<Entity extends ObjectLiteral>(target: EntityTarget<Entity>): TreeRepository<Entity> {\n\n        // tree tables aren't supported by some drivers (mongodb)\n        if (this.connection.driver.treeSupport === false)\n            throw new TreeRepositoryNotSupportedError(this.connection.driver);\n\n        // check if repository is real tree repository\n        const repository = this.getRepository(target);\n        if (!(repository instanceof TreeRepository))\n            throw new RepositoryNotTreeError(target);\n\n        return repository;\n    }\n\n    /**\n     * Gets mongodb repository for the given entity class.\n     */\n    getMongoRepository<Entity extends ObjectLiteral>(target: EntityTarget<Entity>): MongoRepository<Entity> {\n        return this.connection.getMongoRepository<Entity>(target);\n    }\n\n    /**\n     * Gets custom entity repository marked with @EntityRepository decorator.\n     */\n    getCustomRepository<T>(customRepository: ObjectType<T>): T {\n        const entityRepositoryMetadataArgs = getMetadataArgsStorage().entityRepositories.find(repository => {\n            return repository.target === (customRepository instanceof Function ? customRepository : (customRepository as any).constructor);\n        });\n        if (!entityRepositoryMetadataArgs)\n            throw new CustomRepositoryNotFoundError(customRepository);\n\n        const entityMetadata = entityRepositoryMetadataArgs.entity ? this.connection.getMetadata(entityRepositoryMetadataArgs.entity) : undefined;\n        const entityRepositoryInstance = new (entityRepositoryMetadataArgs.target as any)(this, entityMetadata);\n\n        // NOTE: dynamic access to protected properties. We need this to prevent unwanted properties in those classes to be exposed,\n        // however we need these properties for internal work of the class\n        if (entityRepositoryInstance instanceof AbstractRepository) {\n            if (!(entityRepositoryInstance as any)[\"manager\"])\n                (entityRepositoryInstance as any)[\"manager\"] = this;\n        }\n        if (entityRepositoryInstance instanceof Repository) {\n            if (!entityMetadata)\n                throw new CustomRepositoryCannotInheritRepositoryError(customRepository);\n\n            (entityRepositoryInstance as any)[\"manager\"] = this;\n            (entityRepositoryInstance as any)[\"metadata\"] = entityMetadata;\n        }\n\n        return entityRepositoryInstance;\n    }\n\n    /**\n     * Releases all resources used by entity manager.\n     * This is used when entity manager is created with a single query runner,\n     * and this single query runner needs to be released after job with entity manager is done.\n     */\n    async release(): Promise<void> {\n        if (!this.queryRunner)\n            throw new NoNeedToReleaseEntityManagerError();\n\n        return this.queryRunner.release();\n    }\n}\n"],"sourceRoot":".."}