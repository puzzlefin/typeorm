{"version":3,"sources":["../../src/persistence/SubjectExecutor.ts"],"names":[],"mappings":"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","file":"SubjectExecutor.js","sourcesContent":["import {SapDriver} from \"../driver/sap/SapDriver\";\nimport {QueryRunner} from \"../query-runner/QueryRunner\";\nimport {Subject} from \"./Subject\";\nimport {SubjectTopoligicalSorter} from \"./SubjectTopoligicalSorter\";\nimport {SubjectChangedColumnsComputer} from \"./SubjectChangedColumnsComputer\";\nimport {SubjectWithoutIdentifierError} from \"../error/SubjectWithoutIdentifierError\";\nimport {SubjectRemovedAndUpdatedError} from \"../error/SubjectRemovedAndUpdatedError\";\nimport {MongoQueryRunner} from \"../driver/mongodb/MongoQueryRunner\";\nimport {MongoEntityManager} from \"../entity-manager/MongoEntityManager\";\nimport {MongoDriver} from \"../driver/mongodb/MongoDriver\";\nimport {ObjectLiteral} from \"../common/ObjectLiteral\";\nimport {SaveOptions} from \"../repository/SaveOptions\";\nimport {RemoveOptions} from \"../repository/RemoveOptions\";\nimport {BroadcasterResult} from \"../subscriber/BroadcasterResult\";\nimport {OracleDriver} from \"../driver/oracle/OracleDriver\";\nimport {NestedSetSubjectExecutor} from \"./tree/NestedSetSubjectExecutor\";\nimport {ClosureSubjectExecutor} from \"./tree/ClosureSubjectExecutor\";\nimport {MaterializedPathSubjectExecutor} from \"./tree/MaterializedPathSubjectExecutor\";\nimport {OrmUtils} from \"../util/OrmUtils\";\n\n/**\n * Executes all database operations (inserts, updated, deletes) that must be executed\n * with given persistence subjects.\n */\nexport class SubjectExecutor {\n\n    // -------------------------------------------------------------------------\n    // Public Properties\n    // -------------------------------------------------------------------------\n\n    /**\n     * Indicates if executor has any operations to execute (e.g. has insert / update / delete operations to be executed).\n     */\n    hasExecutableOperations: boolean = false;\n\n    // -------------------------------------------------------------------------\n    // Protected Properties\n    // -------------------------------------------------------------------------\n\n    /**\n     * QueryRunner used to execute all queries with a given subjects.\n     */\n    protected queryRunner: QueryRunner;\n\n    /**\n     * Persistence options.\n     */\n    protected options?: SaveOptions & RemoveOptions;\n\n    /**\n     * All subjects that needs to be operated.\n     */\n    protected allSubjects: Subject[];\n\n    /**\n     * Subjects that must be inserted.\n     */\n    protected insertSubjects: Subject[] = [];\n\n    /**\n     * Subjects that must be updated.\n     */\n    protected updateSubjects: Subject[] = [];\n\n    /**\n     * Subjects that must be removed.\n     */\n    protected removeSubjects: Subject[] = [];\n\n    /**\n     * Subjects that must be soft-removed.\n     */\n    protected softRemoveSubjects: Subject[] = [];\n\n    /**\n     * Subjects that must be recovered.\n     */\n    protected recoverSubjects: Subject[] = [];\n\n    // -------------------------------------------------------------------------\n    // Constructor\n    // -------------------------------------------------------------------------\n\n    constructor(queryRunner: QueryRunner, subjects: Subject[], options?: SaveOptions & RemoveOptions) {\n        this.queryRunner = queryRunner;\n        this.allSubjects = subjects;\n        this.options = options;\n        this.validate();\n        this.recompute();\n    }\n\n    // -------------------------------------------------------------------------\n    // Public Methods\n    // -------------------------------------------------------------------------\n\n    /**\n     * Executes all operations over given array of subjects.\n     * Executes queries using given query runner.\n     */\n    async execute(): Promise<void> {\n        // console.time(\"SubjectExecutor.execute\");\n\n        // broadcast \"before\" events before we start insert / update / remove operations\n        let broadcasterResult: BroadcasterResult | undefined = undefined;\n        if (!this.options || this.options.listeners !== false) {\n            // console.time(\".broadcastBeforeEventsForAll\");\n            broadcasterResult = this.broadcastBeforeEventsForAll();\n            if (broadcasterResult.promises.length > 0) await Promise.all(broadcasterResult.promises);\n            // console.timeEnd(\".broadcastBeforeEventsForAll\");\n        }\n\n        // since event listeners and subscribers can call save methods and/or trigger entity changes we need to recompute operational subjects\n        // recompute only in the case if any listener or subscriber was really executed\n        if (broadcasterResult && broadcasterResult.count > 0) {\n            // console.time(\".recompute\");\n            this.insertSubjects.forEach(subject => subject.recompute());\n            this.updateSubjects.forEach(subject => subject.recompute());\n            this.removeSubjects.forEach(subject => subject.recompute());\n            this.softRemoveSubjects.forEach(subject => subject.recompute());\n            this.recoverSubjects.forEach(subject => subject.recompute());\n            this.recompute();\n            // console.timeEnd(\".recompute\");\n        }\n\n        // make sure our insert subjects are sorted (using topological sorting) to make cascade inserts work properly\n\n        // console.timeEnd(\"prepare\");\n\n        // execute all insert operations\n        // console.time(\".insertion\");\n        this.insertSubjects = new SubjectTopoligicalSorter(this.insertSubjects).sort(\"insert\");\n        await this.executeInsertOperations();\n        // console.timeEnd(\".insertion\");\n\n        // recompute update operations since insertion can create updation operations for the\n        // properties it wasn't able to handle on its own (referenced columns)\n        this.updateSubjects = this.allSubjects.filter(subject => subject.mustBeUpdated);\n\n        // execute update operations\n        // console.time(\".updation\");\n        await this.executeUpdateOperations();\n        // console.timeEnd(\".updation\");\n\n        // make sure our remove subjects are sorted (using topological sorting) when multiple entities are passed for the removal\n        // console.time(\".removal\");\n        this.removeSubjects = new SubjectTopoligicalSorter(this.removeSubjects).sort(\"delete\");\n        await this.executeRemoveOperations();\n        // console.timeEnd(\".removal\");\n\n        // recompute soft-remove operations\n        this.softRemoveSubjects = this.allSubjects.filter(subject => subject.mustBeSoftRemoved);\n\n        // execute soft-remove operations\n        await this.executeSoftRemoveOperations();\n\n        // recompute recover operations\n        this.recoverSubjects = this.allSubjects.filter(subject => subject.mustBeRecovered);\n\n        // execute recover operations\n        await this.executeRecoverOperations();\n\n        // update all special columns in persisted entities, like inserted id or remove ids from the removed entities\n        // console.time(\".updateSpecialColumnsInPersistedEntities\");\n        await this.updateSpecialColumnsInPersistedEntities();\n        // console.timeEnd(\".updateSpecialColumnsInPersistedEntities\");\n\n        // finally broadcast \"after\" events after we finish insert / update / remove operations\n        if (!this.options || this.options.listeners !== false) {\n            // console.time(\".broadcastAfterEventsForAll\");\n            broadcasterResult = this.broadcastAfterEventsForAll();\n            if (broadcasterResult.promises.length > 0) await Promise.all(broadcasterResult.promises);\n            // console.timeEnd(\".broadcastAfterEventsForAll\");\n        }\n        // console.timeEnd(\"SubjectExecutor.execute\");\n    }\n\n    // -------------------------------------------------------------------------\n    // Protected Methods\n    // -------------------------------------------------------------------------\n\n    /**\n     * Validates all given subjects.\n     */\n    protected validate() {\n        this.allSubjects.forEach(subject => {\n            if (subject.mustBeUpdated && subject.mustBeRemoved)\n                throw new SubjectRemovedAndUpdatedError(subject);\n        });\n    }\n\n    /**\n     * Performs entity re-computations - finds changed columns, re-builds insert/update/remove subjects.\n     */\n    protected recompute(): void {\n        new SubjectChangedColumnsComputer().compute(this.allSubjects);\n        this.insertSubjects = this.allSubjects.filter(subject => subject.mustBeInserted);\n        this.updateSubjects = this.allSubjects.filter(subject => subject.mustBeUpdated);\n        this.removeSubjects = this.allSubjects.filter(subject => subject.mustBeRemoved);\n        this.softRemoveSubjects = this.allSubjects.filter(subject => subject.mustBeSoftRemoved);\n        this.recoverSubjects = this.allSubjects.filter(subject => subject.mustBeRecovered);\n        this.hasExecutableOperations = this.insertSubjects.length > 0 || this.updateSubjects.length > 0 || this.removeSubjects.length > 0 || this.softRemoveSubjects.length > 0 || this.recoverSubjects.length > 0;\n    }\n\n    /**\n     * Broadcasts \"BEFORE_INSERT\", \"BEFORE_UPDATE\", \"BEFORE_REMOVE\" events for all given subjects.\n     */\n    protected broadcastBeforeEventsForAll(): BroadcasterResult {\n        const result = new BroadcasterResult();\n        if (this.insertSubjects.length)\n            this.insertSubjects.forEach(subject => this.queryRunner.broadcaster.broadcastBeforeInsertEvent(result, subject.metadata, subject.entity!));\n        if (this.updateSubjects.length)\n            this.updateSubjects.forEach(subject => this.queryRunner.broadcaster.broadcastBeforeUpdateEvent(result, subject.metadata, subject.entity!, subject.databaseEntity, subject.diffColumns, subject.diffRelations));\n        if (this.removeSubjects.length)\n            this.removeSubjects.forEach(subject => this.queryRunner.broadcaster.broadcastBeforeRemoveEvent(result, subject.metadata, subject.entity!, subject.databaseEntity));\n        if (this.softRemoveSubjects.length)\n            this.softRemoveSubjects.forEach(subject => this.queryRunner.broadcaster.broadcastBeforeUpdateEvent(result, subject.metadata, subject.entity!, subject.databaseEntity, subject.diffColumns, subject.diffRelations));\n        if (this.recoverSubjects.length)\n            this.recoverSubjects.forEach(subject => this.queryRunner.broadcaster.broadcastBeforeUpdateEvent(result, subject.metadata, subject.entity!, subject.databaseEntity, subject.diffColumns, subject.diffRelations));\n        return result;\n    }\n\n    /**\n     * Broadcasts \"AFTER_INSERT\", \"AFTER_UPDATE\", \"AFTER_REMOVE\" events for all given subjects.\n     * Returns void if there wasn't any listener or subscriber executed.\n     * Note: this method has a performance-optimized code organization.\n     */\n    protected broadcastAfterEventsForAll(): BroadcasterResult {\n        const result = new BroadcasterResult();\n        if (this.insertSubjects.length)\n            this.insertSubjects.forEach(subject => this.queryRunner.broadcaster.broadcastAfterInsertEvent(result, subject.metadata, subject.entity!));\n        if (this.updateSubjects.length)\n            this.updateSubjects.forEach(subject => this.queryRunner.broadcaster.broadcastAfterUpdateEvent(result, subject.metadata, subject.entity!, subject.databaseEntity, subject.diffColumns, subject.diffRelations));\n        if (this.removeSubjects.length)\n            this.removeSubjects.forEach(subject => this.queryRunner.broadcaster.broadcastAfterRemoveEvent(result, subject.metadata, subject.entity!, subject.databaseEntity));\n        if (this.softRemoveSubjects.length)\n            this.softRemoveSubjects.forEach(subject => this.queryRunner.broadcaster.broadcastAfterUpdateEvent(result, subject.metadata, subject.entity!, subject.databaseEntity, subject.diffColumns, subject.diffRelations));\n        if (this.recoverSubjects.length)\n            this.recoverSubjects.forEach(subject => this.queryRunner.broadcaster.broadcastAfterUpdateEvent(result, subject.metadata, subject.entity!, subject.databaseEntity, subject.diffColumns, subject.diffRelations));\n        return result;\n    }\n\n    /**\n     * Executes insert operations.\n     */\n    protected async executeInsertOperations(): Promise<void> {\n        // group insertion subjects to make bulk insertions\n        const [groupedInsertSubjects, groupedInsertSubjectKeys] = this.groupBulkSubjects(this.insertSubjects, \"insert\");\n\n        // then we run insertion in the sequential order which is important since we have an ordered subjects\n        for (const groupName of groupedInsertSubjectKeys) {\n            const subjects = groupedInsertSubjects[groupName];\n\n            // we must separately insert entities which does not have any values to insert\n            // because its not possible to insert multiple entities with only default values in bulk\n            const bulkInsertMaps: ObjectLiteral[] = [];\n            const bulkInsertSubjects: Subject[] = [];\n            const singleInsertSubjects: Subject[] = [];\n            if (this.queryRunner.connection.driver instanceof MongoDriver) {\n                subjects.forEach(subject => {\n                    if (subject.metadata.createDateColumn && subject.entity) {\n                        subject.entity[subject.metadata.createDateColumn.databaseName] = new Date();\n                    }\n\n                    if (subject.metadata.updateDateColumn && subject.entity) {\n                        subject.entity[subject.metadata.updateDateColumn.databaseName] = new Date();\n                    }\n\n                    subject.createValueSetAndPopChangeMap();\n\n                    bulkInsertSubjects.push(subject);\n                    bulkInsertMaps.push(subject.entity!);\n                });\n            } else if (this.queryRunner.connection.driver instanceof OracleDriver) {\n                subjects.forEach(subject => {\n                    singleInsertSubjects.push(subject);\n                });\n            } else {\n                subjects.forEach(subject => {\n\n                    // we do not insert in bulk in following cases:\n                    // - when there is no values in insert (only defaults are inserted), since we cannot use DEFAULT VALUES expression for multiple inserted rows\n                    // - when entity is a tree table, since tree tables require extra operation per each inserted row\n                    // - when oracle is used, since oracle's bulk insertion is very bad\n                    if (subject.changeMaps.length === 0 ||\n                        subject.metadata.treeType ||\n                        this.queryRunner.connection.driver instanceof OracleDriver ||\n                        this.queryRunner.connection.driver instanceof SapDriver) {\n                        singleInsertSubjects.push(subject);\n\n                    } else {\n                        bulkInsertSubjects.push(subject);\n                        bulkInsertMaps.push(subject.createValueSetAndPopChangeMap());\n                    }\n                });\n            }\n\n            // for mongodb we have a bit different insertion logic\n            if (this.queryRunner instanceof MongoQueryRunner) {\n                const manager = this.queryRunner.manager as MongoEntityManager;\n                const insertResult = await manager.insert(subjects[0].metadata.target, bulkInsertMaps);\n                subjects.forEach((subject, index) => {\n                    subject.identifier = insertResult.identifiers[index];\n                    subject.generatedMap = insertResult.generatedMaps[index];\n                    subject.insertedValueSet = bulkInsertMaps[index];\n                });\n\n            } else {\n\n                // here we execute our insertion query\n                // we need to enable entity updation because we DO need to have updated insertedMap\n                // which is not same object as our entity that's why we don't need to worry about our entity to get dirty\n                // also, we disable listeners because we call them on our own in persistence layer\n                if (bulkInsertMaps.length > 0) {\n                    const insertResult = await this.queryRunner\n                        .manager\n                        .createQueryBuilder()\n                        .insert()\n                        .into(subjects[0].metadata.target)\n                        .values(bulkInsertMaps)\n                        .updateEntity(this.options && this.options.reload === false ? false : true)\n                        .callListeners(false)\n                        .execute();\n\n                    bulkInsertSubjects.forEach((subject, index) => {\n                        subject.identifier = insertResult.identifiers[index];\n                        subject.generatedMap = insertResult.generatedMaps[index];\n                        subject.insertedValueSet = bulkInsertMaps[index];\n                    });\n                }\n\n                // insert subjects which must be inserted in separate requests (all default values)\n                if (singleInsertSubjects.length > 0) {\n                    for (const subject of singleInsertSubjects) {\n                        subject.insertedValueSet = subject.createValueSetAndPopChangeMap(); // important to have because query builder sets inserted values into it\n\n                        // for nested set we execute additional queries\n                        if (subject.metadata.treeType === \"nested-set\")\n                            await new NestedSetSubjectExecutor(this.queryRunner).insert(subject);\n\n                        await this.queryRunner\n                            .manager\n                            .createQueryBuilder()\n                            .insert()\n                            .into(subject.metadata.target)\n                            .values(subject.insertedValueSet)\n                            .updateEntity(this.options && this.options.reload === false ? false : true)\n                            .callListeners(false)\n                            .execute()\n                            .then(insertResult => {\n                                subject.identifier = insertResult.identifiers[0];\n                                subject.generatedMap = insertResult.generatedMaps[0];\n                            });\n\n                        // for tree tables we execute additional queries\n                        if (subject.metadata.treeType === \"closure-table\") {\n                            await new ClosureSubjectExecutor(this.queryRunner).insert(subject);\n\n                        } else if (subject.metadata.treeType === \"materialized-path\") {\n                            await new MaterializedPathSubjectExecutor(this.queryRunner).insert(subject);\n                        }\n                    }\n                }\n            }\n\n            subjects.forEach(subject => {\n                if (subject.generatedMap) {\n                    subject.metadata.columns.forEach(column => {\n                        const value = column.getEntityValue(subject.generatedMap!);\n                        if (value !== undefined && value !== null) {\n                            const preparedValue = this.queryRunner.connection.driver.prepareHydratedValue(value, column);\n                            column.setEntityValue(subject.generatedMap!, preparedValue);\n                        }\n                    });\n                }\n            });\n        }\n    }\n\n    /**\n     * Updates all given subjects in the database.\n     */\n    protected async executeUpdateOperations(): Promise<void> {\n        await Promise.all(this.updateSubjects.map(async subject => {\n\n            if (!subject.identifier)\n                throw new SubjectWithoutIdentifierError(subject);\n\n            // for mongodb we have a bit different updation logic\n            if (this.queryRunner instanceof MongoQueryRunner) {\n                const partialEntity = OrmUtils.mergeDeep({}, subject.entity!);\n                if (subject.metadata.objectIdColumn && subject.metadata.objectIdColumn.propertyName) {\n                    delete partialEntity[subject.metadata.objectIdColumn.propertyName];\n                }\n\n                if (subject.metadata.createDateColumn && subject.metadata.createDateColumn.propertyName) {\n                    delete partialEntity[subject.metadata.createDateColumn.propertyName];\n                }\n\n                if (subject.metadata.updateDateColumn && subject.metadata.updateDateColumn.propertyName) {\n                    partialEntity[subject.metadata.updateDateColumn.propertyName] = new Date();\n                }\n\n                const manager = this.queryRunner.manager as MongoEntityManager;\n\n                await manager.update(subject.metadata.target, subject.identifier, partialEntity);\n\n            } else {\n\n                const updateMap: ObjectLiteral = subject.createValueSetAndPopChangeMap();\n\n                // here we execute our updation query\n                // we need to enable entity updation because we update a subject identifier\n                // which is not same object as our entity that's why we don't need to worry about our entity to get dirty\n                // also, we disable listeners because we call them on our own in persistence layer\n                const updateQueryBuilder = this.queryRunner\n                    .manager\n                    .createQueryBuilder()\n                    .update(subject.metadata.target)\n                    .set(updateMap)\n                    .updateEntity(this.options && this.options.reload === false ? false : true)\n                    .callListeners(false);\n\n                if (subject.entity) {\n                    updateQueryBuilder.whereEntity(subject.identifier);\n\n                } else { // in this case identifier is just conditions object to update by\n                    updateQueryBuilder.where(subject.identifier);\n                }\n\n                const updateResult = await updateQueryBuilder.execute();\n                let updateGeneratedMap = updateResult.generatedMaps[0];\n                if (updateGeneratedMap) {\n                    subject.metadata.columns.forEach(column => {\n                        const value = column.getEntityValue(updateGeneratedMap!);\n                        if (value !== undefined && value !== null) {\n                            const preparedValue = this.queryRunner.connection.driver.prepareHydratedValue(value, column);\n                            column.setEntityValue(updateGeneratedMap!, preparedValue);\n                        }\n                    });\n                    if (!subject.generatedMap) {\n                        subject.generatedMap = {};\n                    }\n                    Object.assign(subject.generatedMap, updateGeneratedMap);\n                }\n\n                // experiments, remove probably, need to implement tree tables children removal\n                // if (subject.updatedRelationMaps.length > 0) {\n                //     await Promise.all(subject.updatedRelationMaps.map(async updatedRelation => {\n                //         if (!updatedRelation.relation.isTreeParent) return;\n                //         if (!updatedRelation.value !== null) return;\n                //\n                //         if (subject.metadata.treeType === \"closure-table\") {\n                //             await new ClosureSubjectExecutor(this.queryRunner).deleteChildrenOf(subject);\n                //         }\n                //     }));\n                // }\n            }\n        }));\n    }\n\n    /**\n     * Removes all given subjects from the database.\n     *\n     * todo: we need to apply topological sort here as well\n     */\n    protected async executeRemoveOperations(): Promise<void> {\n        // group insertion subjects to make bulk insertions\n        const [groupedRemoveSubjects, groupedRemoveSubjectKeys] = this.groupBulkSubjects(this.removeSubjects, \"delete\");\n\n        for (const groupName of groupedRemoveSubjectKeys) {\n            const subjects = groupedRemoveSubjects[groupName];\n            const deleteMaps = subjects.map(subject => {\n                if (!subject.identifier)\n                    throw new SubjectWithoutIdentifierError(subject);\n\n                return subject.identifier;\n            });\n\n            // for mongodb we have a bit different updation logic\n            if (this.queryRunner instanceof MongoQueryRunner) {\n                const manager = this.queryRunner.manager as MongoEntityManager;\n                await manager.delete(subjects[0].metadata.target, deleteMaps);\n\n            } else {\n\n                // here we execute our deletion query\n                // we don't need to specify entities and set update entity to true since the only thing query builder\n                // will do for use is a primary keys deletion which is handled by us later once persistence is finished\n                // also, we disable listeners because we call them on our own in persistence layer\n                await this.queryRunner\n                    .manager\n                    .createQueryBuilder()\n                    .delete()\n                    .from(subjects[0].metadata.target)\n                    .where(deleteMaps)\n                    .callListeners(false)\n                    .execute();\n            }\n        }\n    }\n\n    /**\n     * Soft-removes all given subjects in the database.\n     */\n    protected async executeSoftRemoveOperations(): Promise<void> {\n        await Promise.all(this.softRemoveSubjects.map(async subject => {\n\n            if (!subject.identifier)\n                throw new SubjectWithoutIdentifierError(subject);\n\n            // for mongodb we have a bit different updation logic\n            if (this.queryRunner instanceof MongoQueryRunner) {\n                const partialEntity = OrmUtils.mergeDeep({}, subject.entity!);\n                if (subject.metadata.objectIdColumn && subject.metadata.objectIdColumn.propertyName) {\n                    delete partialEntity[subject.metadata.objectIdColumn.propertyName];\n                }\n\n                if (subject.metadata.createDateColumn && subject.metadata.createDateColumn.propertyName) {\n                    delete partialEntity[subject.metadata.createDateColumn.propertyName];\n                }\n\n                if (subject.metadata.updateDateColumn && subject.metadata.updateDateColumn.propertyName) {\n                    partialEntity[subject.metadata.updateDateColumn.propertyName] = new Date();\n                }\n\n                if (subject.metadata.deleteDateColumn && subject.metadata.deleteDateColumn.propertyName) {\n                    partialEntity[subject.metadata.deleteDateColumn.propertyName] = new Date();\n                }\n\n                const manager = this.queryRunner.manager as MongoEntityManager;\n\n                await manager.update(subject.metadata.target, subject.identifier, partialEntity);\n\n            } else {\n\n                // here we execute our soft-deletion query\n                // we need to enable entity soft-deletion because we update a subject identifier\n                // which is not same object as our entity that's why we don't need to worry about our entity to get dirty\n                // also, we disable listeners because we call them on our own in persistence layer\n                const softDeleteQueryBuilder = this.queryRunner\n                    .manager\n                    .createQueryBuilder()\n                    .softDelete()\n                    .from(subject.metadata.target)\n                    .updateEntity(this.options && this.options.reload === false ? false : true)\n                    .callListeners(false);\n\n                if (subject.entity) {\n                    softDeleteQueryBuilder.whereEntity(subject.identifier);\n\n                } else { // in this case identifier is just conditions object to update by\n                    softDeleteQueryBuilder.where(subject.identifier);\n                }\n\n                const updateResult = await softDeleteQueryBuilder.execute();\n                subject.generatedMap = updateResult.generatedMaps[0];\n                if (subject.generatedMap) {\n                    subject.metadata.columns.forEach(column => {\n                        const value = column.getEntityValue(subject.generatedMap!);\n                        if (value !== undefined && value !== null) {\n                            const preparedValue = this.queryRunner.connection.driver.prepareHydratedValue(value, column);\n                            column.setEntityValue(subject.generatedMap!, preparedValue);\n                        }\n                    });\n                }\n\n                // experiments, remove probably, need to implement tree tables children removal\n                // if (subject.updatedRelationMaps.length > 0) {\n                //     await Promise.all(subject.updatedRelationMaps.map(async updatedRelation => {\n                //         if (!updatedRelation.relation.isTreeParent) return;\n                //         if (!updatedRelation.value !== null) return;\n                //\n                //         if (subject.metadata.treeType === \"closure-table\") {\n                //             await new ClosureSubjectExecutor(this.queryRunner).deleteChildrenOf(subject);\n                //         }\n                //     }));\n                // }\n            }\n        }));\n    }\n\n    /**\n     * Recovers all given subjects in the database.\n     */\n    protected async executeRecoverOperations(): Promise<void> {\n        await Promise.all(this.recoverSubjects.map(async subject => {\n\n            if (!subject.identifier)\n                throw new SubjectWithoutIdentifierError(subject);\n\n            // for mongodb we have a bit different updation logic\n            if (this.queryRunner instanceof MongoQueryRunner) {\n                const partialEntity = OrmUtils.mergeDeep({}, subject.entity!);\n                if (subject.metadata.objectIdColumn && subject.metadata.objectIdColumn.propertyName) {\n                    delete partialEntity[subject.metadata.objectIdColumn.propertyName];\n                }\n\n                if (subject.metadata.createDateColumn && subject.metadata.createDateColumn.propertyName) {\n                    delete partialEntity[subject.metadata.createDateColumn.propertyName];\n                }\n\n                if (subject.metadata.updateDateColumn && subject.metadata.updateDateColumn.propertyName) {\n                    partialEntity[subject.metadata.updateDateColumn.propertyName] = new Date();\n                }\n\n                if (subject.metadata.deleteDateColumn && subject.metadata.deleteDateColumn.propertyName) {\n                    partialEntity[subject.metadata.deleteDateColumn.propertyName] = null;\n                }\n\n                const manager = this.queryRunner.manager as MongoEntityManager;\n\n                await manager.update(subject.metadata.target, subject.identifier, partialEntity);\n\n            } else {\n\n                // here we execute our restory query\n                // we need to enable entity restory because we update a subject identifier\n                // which is not same object as our entity that's why we don't need to worry about our entity to get dirty\n                // also, we disable listeners because we call them on our own in persistence layer\n                const softDeleteQueryBuilder = this.queryRunner\n                    .manager\n                    .createQueryBuilder()\n                    .restore()\n                    .from(subject.metadata.target)\n                    .updateEntity(this.options && this.options.reload === false ? false : true)\n                    .callListeners(false);\n\n                if (subject.entity) {\n                    softDeleteQueryBuilder.whereEntity(subject.identifier);\n\n                } else { // in this case identifier is just conditions object to update by\n                    softDeleteQueryBuilder.where(subject.identifier);\n                }\n\n                const updateResult = await softDeleteQueryBuilder.execute();\n                subject.generatedMap = updateResult.generatedMaps[0];\n                if (subject.generatedMap) {\n                    subject.metadata.columns.forEach(column => {\n                        const value = column.getEntityValue(subject.generatedMap!);\n                        if (value !== undefined && value !== null) {\n                            const preparedValue = this.queryRunner.connection.driver.prepareHydratedValue(value, column);\n                            column.setEntityValue(subject.generatedMap!, preparedValue);\n                        }\n                    });\n                }\n\n                // experiments, remove probably, need to implement tree tables children removal\n                // if (subject.updatedRelationMaps.length > 0) {\n                //     await Promise.all(subject.updatedRelationMaps.map(async updatedRelation => {\n                //         if (!updatedRelation.relation.isTreeParent) return;\n                //         if (!updatedRelation.value !== null) return;\n                //\n                //         if (subject.metadata.treeType === \"closure-table\") {\n                //             await new ClosureSubjectExecutor(this.queryRunner).deleteChildrenOf(subject);\n                //         }\n                //     }));\n                // }\n            }\n        }));\n    }\n\n    /**\n     * Updates all special columns of the saving entities (create date, update date, version, etc.).\n     * Also updates nullable columns and columns with default values.\n     */\n    protected updateSpecialColumnsInPersistedEntities(): void {\n\n        // update inserted entity properties\n        if (this.insertSubjects.length)\n            this.updateSpecialColumnsInInsertedAndUpdatedEntities(this.insertSubjects);\n\n        // update updated entity properties\n        if (this.updateSubjects.length)\n            this.updateSpecialColumnsInInsertedAndUpdatedEntities(this.updateSubjects);\n\n        // update soft-removed entity properties\n        if (this.updateSubjects.length)\n            this.updateSpecialColumnsInInsertedAndUpdatedEntities(this.softRemoveSubjects);\n\n        // update recovered entity properties\n        if (this.updateSubjects.length)\n            this.updateSpecialColumnsInInsertedAndUpdatedEntities(this.recoverSubjects);\n\n        // remove ids from the entities that were removed\n        if (this.removeSubjects.length) {\n            this.removeSubjects.forEach(subject => {\n                if (!subject.entity) return;\n\n                subject.metadata.primaryColumns.forEach(primaryColumn => {\n                    primaryColumn.setEntityValue(subject.entity!, undefined);\n                });\n            });\n        }\n\n        // other post-persist updations\n        this.allSubjects.forEach(subject => {\n            if (!subject.entity) return;\n\n            subject.metadata.relationIds.forEach(relationId => {\n                relationId.setValue(subject.entity!);\n            });\n\n            // mongo _id remove\n            if (this.queryRunner instanceof MongoQueryRunner) {\n                if (subject.metadata.objectIdColumn\n                    && subject.metadata.objectIdColumn.databaseName\n                    && subject.metadata.objectIdColumn.databaseName !== subject.metadata.objectIdColumn.propertyName\n                ) {\n                    delete subject.entity[subject.metadata.objectIdColumn.databaseName];\n                }\n            }\n        });\n    }\n\n    /**\n     * Updates all special columns of the saving entities (create date, update date, version, etc.).\n     * Also updates nullable columns and columns with default values.\n     */\n    protected updateSpecialColumnsInInsertedAndUpdatedEntities(subjects: Subject[]): void {\n        subjects.forEach(subject => {\n            if (!subject.entity) return;\n\n            // set values to \"null\" for nullable columns that did not have values\n            subject.metadata.columns.forEach(column => {\n\n                // if table inheritance is used make sure this column is not child's column\n                if (subject.metadata.childEntityMetadatas.length > 0 && subject.metadata.childEntityMetadatas.map(metadata => metadata.target).indexOf(column.target) !== -1)\n                    return;\n\n                // entities does not have virtual columns\n                if (column.isVirtual)\n                    return;\n\n                // update nullable columns\n                if (column.isNullable) {\n                    const columnValue = column.getEntityValue(subject.entity!);\n                    if (columnValue === undefined)\n                        column.setEntityValue(subject.entity!, null);\n                }\n\n                // update relational columns\n                if (subject.updatedRelationMaps.length > 0) {\n                    subject.updatedRelationMaps.forEach(updatedRelationMap => {\n                        updatedRelationMap.relation.joinColumns.forEach(column => {\n                            if (column.isVirtual === true)\n                                return;\n\n                            column.setEntityValue(subject.entity!, updatedRelationMap.value instanceof Object ? column.referencedColumn!.getEntityValue(updatedRelationMap.value) : updatedRelationMap.value);\n                        });\n                    });\n                }\n            });\n\n            // merge into entity all generated values returned by a database\n            if (subject.generatedMap)\n                this.queryRunner.manager.merge(subject.metadata.target as any, subject.entity, subject.generatedMap);\n        });\n    }\n\n    /**\n     * Groups subjects by metadata names (by tables) to make bulk insertions and deletions possible.\n     * However there are some limitations with bulk insertions of data into tables with generated (increment) columns\n     * in some drivers. Some drivers like mysql and sqlite does not support returning multiple generated columns\n     * after insertion and can only return a single generated column value, that's why its not possible to do bulk insertion,\n     * because it breaks insertion result's generatedMap and leads to problems when this subject is used in other subjects saves.\n     * That's why we only support bulking in junction tables for those drivers.\n     *\n     * Other drivers like postgres and sql server support RETURNING / OUTPUT statement which allows to return generated\n     * id for each inserted row, that's why bulk insertion is not limited to junction tables in there.\n     */\n    protected groupBulkSubjects(subjects: Subject[], type: \"insert\" | \"delete\"): [{ [key: string]: Subject[] }, string[]] {\n        const group: { [key: string]: Subject[] } = {};\n        const keys: string[] = [];\n        const groupingAllowed = type === \"delete\" || this.queryRunner.connection.driver.isReturningSqlSupported();\n\n        subjects.forEach((subject, index) => {\n            const key = groupingAllowed || subject.metadata.isJunction ? subject.metadata.name : subject.metadata.name + \"_\" + index;\n            if (!group[key]) {\n                group[key] = [subject];\n                keys.push(key);\n            } else {\n                group[key].push(subject);\n            }\n        });\n\n        return [group, keys];\n    }\n\n}\n"],"sourceRoot":".."}