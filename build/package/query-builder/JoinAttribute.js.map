{"version":3,"sources":["../../src/query-builder/JoinAttribute.ts"],"names":[],"mappings":"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","file":"JoinAttribute.js","sourcesContent":["import {EntityMetadata} from \"../metadata/EntityMetadata\";\nimport {Connection} from \"../connection/Connection\";\nimport {RelationMetadata} from \"../metadata/RelationMetadata\";\nimport {QueryBuilderUtils} from \"./QueryBuilderUtils\";\nimport {QueryExpressionMap} from \"./QueryExpressionMap\";\nimport {Alias} from \"./Alias\";\nimport {ObjectUtils} from \"../util/ObjectUtils\";\n\n/**\n * Stores all join attributes which will be used to build a JOIN query.\n */\nexport class JoinAttribute {\n\n    // -------------------------------------------------------------------------\n    // Public Properties\n    // -------------------------------------------------------------------------\n\n    /**\n     * Join direction.\n     */\n    direction: \"LEFT\"|\"INNER\";\n\n    /**\n     * Alias of the joined (destination) table.\n     */\n    alias: Alias;\n\n    /**\n     * Joined table, entity target, or relation in \"post.category\" format.\n     */\n    entityOrProperty: Function|string;\n\n    /**\n     * Extra condition applied to \"ON\" section of join.\n     */\n    condition?: string;\n\n    /**\n     * Property + alias of the object where to joined data should be mapped.\n     */\n    mapToProperty?: string;\n\n    /**\n     * Indicates if user maps one or many objects from the join.\n     */\n    isMappingMany?: boolean;\n\n    // -------------------------------------------------------------------------\n    // Constructor\n    // -------------------------------------------------------------------------\n\n    constructor(private connection: Connection,\n                private queryExpressionMap: QueryExpressionMap,\n                joinAttribute?: JoinAttribute) {\n        ObjectUtils.assign(this, joinAttribute || {});\n    }\n\n    // -------------------------------------------------------------------------\n    // Public Methods\n    // -------------------------------------------------------------------------\n\n    get isMany(): boolean {\n        if (this.isMappingMany !== undefined)\n            return this.isMappingMany;\n\n        if (this.relation)\n            return this.relation.isManyToMany || this.relation.isOneToMany;\n\n        return false;\n    }\n\n\n    isSelectedCache: boolean;\n    isSelectedEvaluated: boolean = false;\n    /**\n     * Indicates if this join is selected.\n     */\n    get isSelected(): boolean {\n        if (!this.isSelectedEvaluated) {\n            let getValue = () => {\n                for (const select of this.queryExpressionMap.selects) {\n                    if (select.selection === this.alias.name)\n                        return true;\n\n                    if (this.metadata && !!this.metadata.columns.find(column => select.selection === this.alias.name + \".\" + column.propertyPath))\n                        return true;\n                }\n\n                return false;\n            };\n            this.isSelectedCache = getValue();\n            this.isSelectedEvaluated = true;\n        }\n        return this.isSelectedCache;\n\n    }\n\n    /**\n     * Name of the table which we should join.\n     */\n    get tablePath(): string {\n        return this.metadata ? this.metadata.tablePath : this.entityOrProperty as string;\n    }\n\n    /**\n     * Alias of the parent of this join.\n     * For example, if we join (\"post.category\", \"categoryAlias\") then \"post\" is a parent alias.\n     * This value is extracted from entityOrProperty value.\n     * This is available when join was made using \"post.category\" syntax.\n     */\n    get parentAlias(): string|undefined {\n        if (!QueryBuilderUtils.isAliasProperty(this.entityOrProperty))\n            return undefined;\n\n        return this.entityOrProperty.substr(0, this.entityOrProperty.indexOf(\".\"));\n    }\n\n    /**\n     * Relation property name of the parent.\n     * This is used to understand what is joined.\n     * For example, if we join (\"post.category\", \"categoryAlias\") then \"category\" is a relation property.\n     * This value is extracted from entityOrProperty value.\n     * This is available when join was made using \"post.category\" syntax.\n     */\n    get relationPropertyPath(): string|undefined {\n        if (!QueryBuilderUtils.isAliasProperty(this.entityOrProperty))\n            return undefined;\n\n        return this.entityOrProperty.substr(this.entityOrProperty.indexOf(\".\") + 1);\n    }\n\n    relationCache: RelationMetadata|undefined;\n    relationEvaluated: boolean = false;\n    /**\n     * Relation of the parent.\n     * This is used to understand what is joined.\n     * This is available when join was made using \"post.category\" syntax.\n     * Relation can be undefined if entityOrProperty is regular entity or custom table.\n     */\n    get relation(): RelationMetadata | undefined {\n        if (!this.relationEvaluated) {\n            let getValue = () => {\n                if (!QueryBuilderUtils.isAliasProperty(this.entityOrProperty))\n                    return undefined;\n\n                const relationOwnerSelection = this.queryExpressionMap.findAliasByName(this.parentAlias!);\n                let relation = relationOwnerSelection.metadata.findRelationWithPropertyPath(this.relationPropertyPath!);\n\n                if (relation) {\n                    return relation;\n                }\n\n                if (relationOwnerSelection.metadata.parentEntityMetadata) {\n                    relation = relationOwnerSelection.metadata.parentEntityMetadata.findRelationWithPropertyPath(this.relationPropertyPath!);\n                    if (relation) {\n                        return relation;\n                    }\n                }\n\n                throw new Error(`Relation with property path ${this.relationPropertyPath} in entity was not found.`);\n            };\n            this.relationCache = getValue.bind(this)();\n            this.relationEvaluated = true;\n        }\n        return this.relationCache;\n    }\n\n    /**\n     * Metadata of the joined entity.\n     * If table without entity was joined, then it will return undefined.\n     */\n    get metadata(): EntityMetadata|undefined {\n\n        // entityOrProperty is relation, e.g. \"post.category\"\n        if (this.relation)\n            return this.relation.inverseEntityMetadata;\n\n        // entityOrProperty is Entity class\n        if (this.connection.hasMetadata(this.entityOrProperty))\n            return this.connection.getMetadata(this.entityOrProperty);\n\n        return undefined;\n\n        /*if (typeof this.entityOrProperty === \"string\") { // entityOrProperty is a custom table\n\n            // first try to find entity with such name, this is needed when entity does not have a target class,\n            // and its target is a string name (scenario when plain old javascript is used or entity schema is loaded from files)\n            const metadata = this.connection.entityMetadatas.find(metadata => metadata.name === this.entityOrProperty);\n            if (metadata)\n                return metadata;\n\n            // check if we have entity with such table name, and use its metadata if found\n            return this.connection.entityMetadatas.find(metadata => metadata.tableName === this.entityOrProperty);\n        }*/\n    }\n\n    /**\n     * Generates alias of junction table, whose ids we get.\n     */\n    get junctionAlias(): string {\n        if (!this.relation)\n            throw new Error(`Cannot get junction table for join without relation.`);\n\n        return this.relation.isOwning ? this.parentAlias + \"_\" + this.alias.name : this.alias.name + \"_\" + this.parentAlias;\n    }\n\n    get mapToPropertyParentAlias(): string|undefined {\n        if (!this.mapToProperty)\n            return undefined;\n\n        return this.mapToProperty!.split(\".\")[0];\n    }\n\n    get mapToPropertyPropertyName(): string|undefined {\n        if (!this.mapToProperty)\n            return undefined;\n\n        return this.mapToProperty!.split(\".\")[1];\n    }\n\n}\n"],"sourceRoot":".."}